[Spring：](#1057-1574598434778)

[SpringBean](#1525-1574598317675)

[SpringBoot](#5030-1571120974192)

[Hibernate](#6033-1571120979207)

[Mybatis](#9052-1571121785042)

[**Spring**](https://blog.csdn.net/a745233700/article/details/80959716)**：**

优点：1：方便解耦，简化开发。IOC容器处理依赖关系降低组件耦合性  2：AOP（面向切面编程）的支持。 3：声明式事物的支持。 4：高度开放性，方便集成各种主流框架hibernate。低侵式设计，代码污染低。

**IOC控制反转**：IOC就是控制反转。就是对象的创建权反转交给Spring，由容器控制程序之间的依赖关系，作用是实现了程序的解耦合，而非传统实现中，由程序代码直接操控。(依赖)控制权由应用代码本身转到了外部容器，由容器根据配置文件去创建实例并管理各个实例之间的依赖关系，控制权的转移，是所谓反转，并且由容器动态的将某种依赖关系注入到组件之中。BeanFactory 是Spring IoC容器的具体实现与核心接口，提供了一个先进的配置机制，使得任何类型的对象的配置成为可能，用来包装和管理各种bean。

最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，这里用的就是java的反射机制，通过反射在运行时动态的去创建、调用对象。spring就是根据配置文件在运行时动态的去创建对象，并调用对象的方法的。

**DI依赖注入**：指Spring创建对象的过程中，将对象依赖属性通过配置进行注入。依赖注入是控制反转的基础，在容器实例化对象的时候主动的将被调用者（或者说它的依赖对象）注入给调用对象。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。

Spring的IOC有三种注入方式 ：1.set方法注入 2.构造器注入 3.注解注入

**AOP面向切面编程**：通过动态代理的方式为程序添加统一功能，集中解决一些公共问题。

AOP，一般称为面向切面编程，作为面向对象的一种补充，用于解剖封装好的对象内部，找出其中对多个对象产生影响的公共行为，并将其封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），切面将那些与业务无关，却被业务模块共同调用的逻辑提取并封装起来，减少了系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。 AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。

IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。

三种配置：基于XML的，基于注释的，基于Java的

**SpringBean**

**Bean生命周期：**

**Bean作用域：**

singleton，prototype，request，session，global session

**Spring框架中的设计模式**

工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。

代理设计模式 : Spring AOP 功能的实现。

单例设计模式 : Spring 中的 Bean 默认都是单例的。

模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。

包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。

观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。

适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。

**SpringBoot**

Spring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。

以下是Spring Boot中的一些特点：

 1：创建独立的spring应用。

 2：嵌入Tomcat, Jetty 而且不需要部署他们。

 3：提供的“starters” poms来简化Maven配置spring-boot-starter-web

 4：尽可能自动配置spring应用。

 5：提供生产指标,健壮检查和外部化配置

 6：绝对没有代码生成和XML配置要求

**SpringBoot启动流程：**

核心注解：@SpringBootApplication: 

1@SpringBootConfiguration 2@EnableAutoConfiguration [3@ComponentScan](mailto:3@ComponentScan)

配置文件：application，bootstrap

配置文件格式：.properties和.yml（数据序列化语言，更加结构化，分层配置）

日志框架：Log4j2，Logback

data-jpa可以实现分页

**Hibernate**

传统的持久层框架都是采用Java JDBC的连接方式进行数据库的访问和操作，需要人为的编写大量的SQL或者代码，同时还需要将获得的数据进行转换或封装后往外传，其实对于大项目而言这是一个非常烦琐的过程。

Hibernate框架是一个半自动化的持久层框架，可以减少大量的SQL、代码编写工作，省掉很大部分的工作量，在这个框架中，当我们需要相关操作时，不用再关注数据库表也不用再去一行行的查询数据库，只需要通过持久化一个类的方式就可以完成增删改查的功能，因为框架的内部已经实现了很多对数据库的操作方法，我们只需要调用即可，做的最多的工作都在持久化类上。

**Mybatis**

MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射， 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的繁杂。它可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java对象映射成数据库中的记录。

Hibernate固然优秀，但是跟Mybatis相比，它的封装太过于死板，对一些复杂的sql，开发人员更喜欢手动的编写一些代码，而不是通过特定的HQL语言去编写，这样会间接的增加工作量，而且Mybatis更好上手，学习成本比Hibernate要低很多，但是有一点不得不承认，Hibernate的开源社区人数要碾压Mybatis的，毕竟国外很多大佬还是喜欢用Hibernate的，后期可以详细探索探索。





[**Java内存模型** ](https://www.jianshu.com/p/76959115d486)

**JVM**

定义：JVM就是Java虚拟机，是整个Java实现跨平台最核心的部分，是基于栈执行的，所有的Java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。JVM 通过抽象操作系统和 CPU 结构，提供了一种与平台无关的代码执行方法。

**1. Java代码编译和执行的整个过程**

- Java源码编译机制：Java源码编译器将Java代码.java文件到JVM字节码.class文件
- 类加载机制：JVM的类加载是通过ClassLoader及其子类来完成的

（双亲委派）Classloader：启动类加载器--扩展类加载器--应用程序类加载器--用户自定义类加载器  

- 类执行机制：JVM是基于堆栈结构运行方式的虚拟机，JVM为每个新创建的线程都分配一个堆栈，以帧为单位的压栈和出栈操作。

JVM执行class字节码，线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。

**2.** [**JVM内存管理及垃圾回收机制**](https://www.cnblogs.com/handsomeye/p/5442879.html)**：**

JVM内存结构分为：Java堆，方法区，程序计数器，本地方法栈，虚拟机栈

程序计数器：CPU寄存器保存程序当前执行的指令地址。

Java栈是为执行Java方法服务，每个线程都有自己的Java栈，

而本地方法栈则是为执行本地方法服务的。Java中的堆是用来存储对象本身的以及数组

**垃圾回收机制**

用于在空闲时间以不定时的方式动态回收无任何引用的对象占据的内存空间，GC回收的是堆区和方法区的内存。

**可达性分析：**通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到 GC Roots 没有任何的引用链相连时(从 GC Roots 到这个对象不可达)时，证明此对象不可用。

![img](https:////note.youdao.com/src/42CA57D4D53F4789848235371988E5E5)

**垃圾回收算法**主要有三种，分别是

**标记-清除算法：**首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

**复制算法：**将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块内存用完了，将复制到另外一块上面，然后在把已使用过的内存空间一次清理掉。

**标记-整理算法：**标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让索引端移动，然后直接清理掉端边界以外的内存。

分代收集算法：对于不同的代，采用不同的收集算法：

新生代：由于对象存活时间短，数量少，因此可以采用复制算法该算法效率比较快。

老年代：由于对象存活时间长，数量多，可以采用标记-清除算法或是标记-整理算法。

新生代：Serial收集器，ParNew，Parallel Scavenge

老年代：Serial Old，CMS，Parallel Old

最新：G1收集器

**反射机制**

反射机制就是动态加载对象，并对对象进行剖析。允许程序在执行期借助于Reflection API取得任何类的內部信息，并能直接操作任意对象的内部属性及方法。这种动态获取信息以及动态调用对象方法的功能成为Java反射机制。

反射就是把java类中的各种成分映射成一个个的Java对象

**动态代理**

动态代理是指代理类是在JVM运行时动态生成的。效率比静态代理要低，但提高了代码的简洁度和开发工作。

SpringAOP动态代理主要两种实现：JDK动态代理和CGlib动态代理，JDK动态代理是基于Java反射功能来实现的，而CGlib动态代理借助于ASM字节码生成工具来生成代理类。

**封装，继承，多态**

**封装**隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。

**继承**是为了重用父类代码。同时继承也为实现多态做了铺垫。

**多态**就是指一个引用变量在不同的情况下的多种状态。多态是指通过指向父类的指针，来调用在不同子类中实现的方法。三要素：继承，重写，父类引用指向子类对象

如果b类继承自a类，在main方法中new出b的对象(不带参数)，那么他执行的顺序是：

父类a的静态方法-->子类b的静态方法-->父类a的非静态方法-->父类a的无参构造-->子类b的非静态方法-->子类b的无参构造方法

在父类无参构造里面调用了父类的XX方法 且子类重写了父类的XX方法，那么不会调用父类的XX，优先调用子类的XX方法，但是仍然可以在子类的XX方法里面使用super调用父类的XX方法。

**HashMap**  

底层是用hash数组和单链表

键值对（key-value)    ：不同步，不是线程安全，允许键值都为null，映射无序，快速失败   初始容量（capacity）：默认16    加载因子（loadfactor)：默认0.75

扩容极限（threshold) ：元素个数大于capacity*loadfactor， 扩容2n，

进行rehash是非常耗资源的   jdk1.8 链表长度大于8时转换为**红黑树**

**红黑树性质** 1、每个结点或是红色的，或是黑色的 2、根节点是黑色的 3、每个叶结点（NIL）是黑色的 4、如果一个节点是红色的，则它的两个儿子都是黑色的。 5、对于每个结点，从该结点到其叶子结点构成的所有路径上的黑结点个数相同。

当进行put操作时，首先通过hashcode()方法计算key的hash值，找到链表索引，看索引上是否有相同的key值，有就更新value，没有就加在链表尾

当进行get操作时，根据key的hashcode()和equals()方法算出元素在数组中的下标，遍历Entry对象链表，找到元素返回对应的value

![img](https:////note.youdao.com/src/715D0F71903E4E89BF5A13650D4DEDBC)

**缺点：**1线程不安全，2每次计算hash值都是同一个值，造成链表长度过长的问题,3每次计算hash值都是不同的值，造成数组不断的扩容。JDK1.8后使用红黑树代替了链表。

**ConcurrentHashMap** 线程安全，支持16个线程并发操作，

- 分段锁（Segment）的设计，把一个大的Map拆分成N个小的HashTable
- Segment继承ReentrantLock,每个Segment都有一把锁，保证线程安全。

非阻塞，效率高。

**HashTable** 线程安全，key和value不允许null。HashTable中hash数组默认大小是11扩容2n+1。任何操作都会把整个表锁住，阻塞，效率低。

**TreeMap** 继承自SortedMap接口，非线程安全，基于红黑树实现，适用于顺序遍历键

**ArrayList**底层的数据结构是基于动态数组。适合查找。默认容量为10。扩容按照1.5倍+1增长

**LinkedList**底层的数据结构是基于双向循环链表。适合增删。比ArrayList更占内存，

**接口和抽象类的区别**

**从设计层面来说，抽象是对类的抽象，是一种模板设计，可以实现代码重用，接口是行为的抽象，是一种行为的规范。**

**接口** （Interface修饰）所有的方法在接口中不能有实现（所有方法都是抽象的）。接口无法被实例化。一个类只能继承一个类，但是可以实现多个接口。一个类实现接口的话要实现接口中的所有方法。成员变量默认是public static final有初始值，成员方法默认是public abstract，

**抽象类**（abstract修饰）可包含抽象和非抽象的方法，含有抽象方法的类必是抽象类。抽象类不能实例化，抽象类中的抽象方法只有方法体，没有具体实现。如果子类没有实现抽象父类的所有抽象方法，那么子类也必须定义为抽象类。抽象方法可以是public，protected或者是private，变量是friendly的可以在子类中重新定义。

如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类

如果你想实现多重继承，那么你必须使用接口

如果基本功能在不断改变，那么就需要使用抽象类

**重写和重载的区别**

**Override**(重写）父类与子类之间多态性的一种表现。对接口方法的实现中经常出现。

方法名，参数，返回值，异常都一致，方法被定义为final不能被重写。

**Overload**(重载)  是一个类中多态性的一种表现。

方法名必须相同，参数列表不同（类型，个数，顺序）

**final，finally，finalize的区别**

**final** 被final修饰的类，就意味着不能再派生出新的子类，变量或方法声明为final，可以保证他们在使用的过程中不被修改，只能读取使用。被声明为final的变量必须在声明时给出变量的初始值，final声明的方法不能重写。

**finally** 是在异常处理时提供finally块来执行任何清除操作。不管有没有异常被抛出、捕获，finally块都会被执行。

**finalize** 是方法名，在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。

**String、StringBuffer、StringBuilder的区别**

![img](https:////note.youdao.com/src/02F3B0A48A5F4F999195C68918DF6522)

在执行速度上：Stringbuilder->Stringbuffer->String

**String**：不可变，即字符串常量。操作少量的数据

**StringBuffer**：可变，效率低，线程安全，会在append等方法上加synchronized关键字，进行同步。多线程操作字符串缓冲区下操作大量数据

**StringBuilder**：可变，效率高，线程不安全。单线程操作字符串缓冲区下操作大量数据

+号拼接的原理是会在底层new一个StringBuilder，例如：str = str + “a”具体就是new StringBuilder().append(str).append("a"); 影响效率。

**==和equals的区别**

1）对于 **= =**，如果作用于基本数据类型的变量，则直接比较其存储的**值**是否相等；如果作用于引用类型的变量，则比较的是所指向的**对象的地址**。

2）对于**equals**方法，注意：equals方法不能作用于基本数据类型的变量；

如果没有对equals重写，则比较的是引用类型的变量所指向的**对象的地址**；

诸如String、Date等类进行了重写的话，比较的是所指向的对**象的内容**。

对于**字符串**，==比较两个对象的内存地址，equals比较字符串内容。

**sleep()和wait()的区别**

①sleep是Thread类的方法，导致此线程暂停执行指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。

②wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。

**装箱和拆箱的区别**

Java为每种基本数据类型都提供了对应的包装器类型，

装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。

**synchronized与Lock的区别**

\##synchronized是Java关键字，在JVM层面实现了对临界资源的同步互斥访问，通过对对象的头文件来操作，从而达到加锁和释放锁目的。不能相应中断。同一时刻不管是读还是写都只能有一个线程对共享资源操作，其他线程只能等待。锁的释放由虚拟机来完成，不用人工干预，不过此即使缺点也是优点，优点是不用担心会造成死锁，缺点是由可能获取到锁的线程阻塞之后其他线程会一直等待，性能不高。每一个使用synchronize修饰的方法都是临界区。使用synchronize修饰的对象，那么同一时间只能有一个执行线程访问，如果其他线程试图访问这个对象的其他方法，都将被挂起。synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能）

\##Lock可定时的、可轮询的与可中断的锁获取操作，提供了读写锁、公平锁和非公平锁。缺点是需手动释放锁unlock，不适合JVM进行堆栈跟踪。

1. synchronized是Java关键字，是JVM层面，Lock是纯java手写的接口类，
2.  synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。
3.  lock等待锁过程中可以用interrupt来终端等待，而synchronized只能等待锁的释放，不能响应中断；
4.  lock可以通过trylock来知道有没有获取锁，而synchronized不能；
5.  Lock可以提高多个线程进行读操作的效率。

两者都是利用线程的阻塞来实现同步的，都是使用了基于锁的阻塞算法，只不过一个是内置锁，一个是显示锁。性能方便也没有什么差异，就未来来看，更可能提升性能的是Synchronized而不是ReentrantLock，因为Synchronized是JVM的内置属性，具备进一步优化的可能性。不需要高级功能时优先使用Synchronized。在竞争激烈时使用ReentrantLock

**Synchronized底层实现**通过monitorenter/monitorexit指令实现的。每个对象都有个Monitor,当monitor被占用的时候，对象进入锁定状态。

synchronized修饰静态方法以及同步代码块锁的是类，线程想要执行对应同步代码，需要获得**类锁**。synchronized修饰成员方法，线程获取的是当前调用该方法的对象实例的**对象锁**

**锁的升级降级**

所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。当没有竞争出现时，默认会使用偏斜锁。

- 锁的升级：偏斜锁==>轻量级锁==>重量级锁
- 锁的降级：重量级锁==>轻量级锁==>偏斜锁

[**volatile关键字**](https://www.cnblogs.com/chengxiao/p/6528109.html)

一是保证共享变量对所有线程的可见性；

二是禁止指令重排序优化。

CAS (compare and swap) 比较并交换，就是将内存值与预期值进行比较，如果相等才将新值替换到内存中，并返回true表示操作成功；如果不相等，则直接返回false表示操作失败。

**IO****与****NIO****的区别**

https://www.cnblogs.com/straybirds/p/9484598.html

IO: 同步阻塞方式，传统的java.io,基于流模型实现。部分网络API

NIO: 同步非阻塞，面向缓冲区实现。客户端和服务器端通过Channel通讯，实现多路复用。

NIO核心组件：Channel，Buffer，Selector

1.Buffer：Java NIO BUffer用于和NIO Channel交互。我们从Channel中读取数据到buffer里，从buffer把数据写入到channel；

buffer本质上就是一块内存区

2.Channel通常来说NIO中的所有IO都是从Channel（通道）开始的

\3. Selector一般称为选择器，也称为多路复用器。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel的状态是否处于可读、可写。因此可以实现单线程管理多个Channel

Java NIO的选择器允许一个单独的线程来监视多个输入通道

AIO：异步非阻塞，Asynchronous IO，基于事件和回调机制。

以InputStream（输入）/OutputStream（输出）为后缀的是字节流；以8位为单位对二进制的数据进行操作，对数据不进行转换

以Reader（输入）/Writer（输出）为后缀的是字符流。以字符为单位对数据进行操作，在读的时候将二进制数据转为字符，在写的时候将字符转为二进制数据

**类加载**

**双亲委派模型**

自定义类加载器-》应用程序类加载器-》扩展类加载器-》启动类加载器

在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（**运行时数据区**）。包括：**程序计数器**(Program Counter Register)、**Java栈**(VM Stack)、**本地方法栈**(Native Method Stack)、**本地方法区**(Method Area)、**Java堆**(Heap)。

**异常机制：**

异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。

![img](https:////note.youdao.com/src/214A1AA70EA248169EFDE4DA23C8DAC7)

NullPointerException：空指针异常，调用了未经初始化的对象或不存在的对象

ArithmeticException：数学运算异常，除以零操作

ArrayIndexOutOfBoundsException：数组下标越界

ClassNotFoundException：指定的类不存在

StackOverflowError:堆栈溢出错误

IllegalAccessException：没有访问权限

1.继承自RuntimeException或Error的是非检查型异常，而继承自Exception的则是检查型异常

2.对非检查型类异常可以不用捕获，而检查型异常则必须用try语句块进行处理或者把异常交给上级方法处理总之就是必须写代码处理它。

**catch语句块的执行顺序：**当用多个catch语句时，catch语句块在次序上有先后之分。从最前面的catch语句块依次先后进行异常类型匹配，这样如果父异常在子异常类之前，那么首先匹配的将是父异常类，子异常类将不会获得匹配的机会，也即子异常类型所在的catch语句块将是不可到达的语句。所以，一般将父类异常类即Exception老大放在catch语句块的最后一个。

![img](https:////note.youdao.com/src/A4D94AE4EEA7402AAE15F3D7F7404F9D)

**值类型的数据存储在内存的栈中；引用类型的数据存储在内存的堆中**

**基本数据类型、局部变量存储在内存的栈中；new创建的实例化对象及数组存储在内存的堆中**

**中断：是一种协作机制，**也就是说通过中断并不能直接中断另外一个线程，而需要被中断的线程自己处理中断。每个线程对象里都有一个boolean类型的标识，代表着是否有中断请求（该请求可以来自所有线程，包括被中断的线程本身）。

**快速失败和安全失败**

Fail-Fast和Fail-Safe: Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。

**Java创建对象的几种方式（重要）：**

(1) 用new语句创建对象，这是最常见的创建对象的方法。

(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。

(3) 调用对象的clone()方法。

(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。

**transient**关键字,你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。

**线程安全**

主要原因有两点：存在共享数据，存在多条线程共同操作共享数据。

**死锁的四个必要条件：**

1互斥条件 2请求和保持条件 3不剥夺条件 4循环等待条件

**线程同步**

- wait():使一个线程处于等待状态，并且释放所持有的对象的lock。
- sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。
- notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
- Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。

[**Java**](http://lib.csdn.net/base/javaee)提供了3个非常重要的方法来巧妙地解决**线程间的通信**问题。这3个方法分别是：wait()、notify()和notifyAll()。调用wait()方法可以使调用该方法的线程释放共享资源的锁，然后从运行态退出，进入等待队列，直到被再次唤醒。而调用notify()方法可以唤醒等待队列中第一个等待同一共享资源的线程，并使该线程退出等待队列，进入可运行态。调用notifyAll()方法可以使所有正在等待队列中等待同一共享资源的线程从等待状态退出，进入可运行状态，此时，优先级最高的那个线程最先执行。

**sleep()和yield()的区别**

①sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；

② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；

③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；

④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。

**创建线程的三种方式****：**

1.继承Thread类

2.实现Runable接口(推荐)

3.使用Executor框架创建线程池

4.实现Callable接口通过FutureTask包装器

**4****种常用线程池：**

- Executors.newCacheThreadPool()可缓存线程池：先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务。
- Executors.newFixedThreadPool(int n)：创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。
- Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行
- Executors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

**进程是系统进行资源分配和调度的基本单位**

**线程是程序执行的最小单位**

**一个程序至少有一个进程，一个进程至少有一个线程**

**每个进程有独立的代码和数据空间，进程切换开销大**

**同类线程共享代码和数据空间，有独立运行栈和程序计数器，切换开销小**

**进程间不会相互影响；一个线程挂掉会导致整个进程挂掉。**

[**进程间通信（IPC）**](https://www.cnblogs.com/LUO77/p/5816326.html)

**1.管道pipe** 半双工

**2.命名管道FIFO**

**3.消息队列message queue**

**4.信号量semophore** PV操作

**5.共享内存shared memory**

**6.套接字socket**

**7.信号sinal**

Socket和Streams支持不同主机上的两个进程IPC

**死锁的四个必要条件：**

1互斥条件 2请求和保持条件 3不剥夺条件 4循环等待条件

**创建线程：**

1.实现Runnable接口

2.继承Thread类

3.通过Callable和Future创建线程

[**Java**](http://lib.csdn.net/base/javaee)提供了3个非常重要的方法来巧妙地解决线程间的通信问题。这3个方法分别是：wait()、notify()和notifyAll()。调用wait()方法可以使调用该方法的线程释放共享资源的锁，然后从运行态退出，进入等待队列，直到被再次唤醒。而调用notify()方法可以唤醒等待队列中第一个等待同一共享资源的线程，并使该线程退出等待队列，进入可运行态。调用notifyAll()方法可以使所有正在等待队列中等待同一共享资源的线程从等待状态退出，进入可运行状态，此时，优先级最高的那个线程最先执行。

**线程池**

**原理：**

1、线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则执行第二步。 

2、线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里进行等待。如果工作队列满了，则执行第三步。

3、线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。

**优点：**

1、降低资源消耗 

可以重复利用已创建的线程降低线程创建和销毁造成的消耗。 

2、提高响应速度 

当任务到达时，任务可以不需要等到线程创建就能立即执行。 

3、提高线程的可管理性 

线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控

线程分为守护线程和非守护线程（即用户线程）。守护线程最典型的应用就是 GC (垃圾回收器)

**四种线程池：**

newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。

newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

**线程同步的方式：**

1.同步方法，使用synchronized关键字修饰方法

2.同步代码块，使用synchronized关键字修饰代码块

3.使用特殊域变量volatile实现线程同步

4.使用重入锁实现线程同步，ReentrantLock创建实例，lock()获得锁，unlock()释放锁

5.使用局部变量实现线程同步，ThreadLocal() : 创建一个线程本地变量

6.使用阻塞队列实现线程同步，BlockingQueue<E>定义了阻塞队列的常用方法，add(),offer(),put()

7.使用原子变量实现线程同步,

线程分为**守护线程和非守护线程**

只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。

**守护线程最典型的应用就是 GC (垃圾回收器)**

**守护线程和用户线程**的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。

**ThreadLocal** 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。

Long.valueOf()返回包装类型

Long.parseLong()返回基本数据类型



[MySQL语句](#7993-1574143293739)

[JDBC数据库连接的基本步骤：](#50szgf1545616577194)

[数据库索引](#6cslg1538054724090)

[数据库事务四大特性：](#17oymh1538054724245)

[数据库事务隔离四个级别：](#60jepc1545275237832)

[数据库三范式：](#6022-1573099424154)

[数据库的五大约束：](#4033-1539584037711)

[脏读，幻读，不可重复读的区别：](#1841-1562940984468)

[数据库的优化：](#96fsfd1540436594502)

[MySQL的行锁和表锁：](#4120-1562941301848)

[乐观锁和悲观锁的区别：](#7398-1562941315560)

[MySql的内连接、左连接、右连接的区别：](#1127-1562941325570)

[聚簇索引和非聚簇索引的差异性:](#7029-1574143466872)

**MySQL语句**

创建数据库 create database test_db;

删除数据库 drop database test_db;

选择数据库 use test_db; 显示数据库 show test_db;

创建数据表

CREATE TABLE table_name (column_name column_type);

CREATE TABLE IF NOT EXISTS `book`(    `id` INT UNSIGNED AUTO_INCREMENT,    `title` VARCHAR(100) NOT NULL,    `author` VARCHAR(40) NOT NULL,    `date` DATE,    PRIMARY KEY ( `id` )   )ENGINE=InnoDB DEFAULT CHARSET=utf8;

删除表内数据

delete from table_name where 删除条件;

清除表内数据，保存表结构

truncate table table_name;

删除表用 drop，就是啥都没了

drop table table_name;

向数据表中插入数据

insert into table_name ( field1, field2,...fieldN )...

读取数据表：

select * from table_name;

查询数据表：

select column_name1,column_name2 from table_name where 条件 limit N offset M     

修改或更新数据表：

update table_name set field1=new1, field2=new2 WHERE Clause

从表中的website字段中以COM结尾的所有记录：

select * from table_name where website LIKE '%COM'; '%a%'    //含有a的数据 '_a_'    //三位且中间字母是a的

binary   //区分大小写

UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。

SELECT column1,column2 FROM table_name [WHERE conditions] UNION [ALL | DISTINCT] SELECT column1,column2 FROM table_name [WHERE conditions]

ORDER BY column_name;		 排序[ASC||DESC]

如果字符集采用的是 utf8(万国码)，需要先对字段进行转码然后排序：

ORDER BY CONVERT(column using gbk);

SELECT 列名称 FROM 表名称 UNION	  SELECT 列名称 FROM 表名称 ORDER BY 列名称； SELECT 列名称 FROM 表名称 UNION ALL SELECT 列名称 FROM 表名称 ORDER BY 列名称；

 GROUP BY column_name;

**JDBC数据库连接的基本步骤：**

1.加载JDBC驱动到JVM，将Driver类的实例注册到DriverManager类中

2.提供JDBC连接的URL，定义了连接数据库时的协议、子协议、数据源标识

3.创建数据库的连接，向java.sql.DriverManager请求并获得Connection对象

4.创建一个Statement

5.执行SQL语句，Statement接口提供了三种执行SQL语句的方法：executeQuery 、executeUpdate	和execute

6.获取并操作结果集，

7.关闭JDBC对象  

操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声明顺序相反：  

1、关闭记录集  2、关闭声明  3、关闭连接对象

Class.forName("com.mysql.jdbc.Driver");//指定连接类型 Connection con= DriverManager.getConnection(url, user, password);//获取连接 //获得元数据 DatabaseMetaData metaData = connection.getMetaData(); //获得表信息 ResultSet tables = metaData.getTables(null, null, null, new String[]{"TABLE"}); while(tables.next()){    System.out.println(tables.getString("TABLE_NAME")); } PreparedStatement ps = connection.prepareStatement(sql);//准备执行语句 ResultSet rs = ps.executeQuery();//执行语句  //关闭连接 rs.close(); ps.close(); con.close();

**数据库索引**

是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。**索引的实现通常使用B树及其变种B+树**。

**优点**解答:创建索引可以大大提高系统的性能。 (1) 大大加快数据的检索速度，这也是创建索引的最主要原因。 (2) 创建唯一性索引，保证数据库表中每一行数据的唯一性。 (3) 加速表和表之间的连接。 (4) 在使用分组(group by)和排序(order by)子句进行数据检索时，可以显著减少查询中分组和排序的时间。 (5) 通过使用索引，可以在查询的过程中，使用查询优化器，提高系统的性能。 那么索引有如此多的优点，为什么不对表中的**每一个列创建一个索引**呢？这是因为增加索引也有许多不利的方面。 (1) 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 (2) 索引需要占用物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 (3) 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 一般来说，应该在这些列上**创建索引**: (1) 在经常需要搜索的列上创建索引，可以加快搜索的速度; (2) 在作为主键的列上创建索引，强制该列的唯一性和组织表中数据的排列结构; (3) 在经常用在连接的列上创建索引，这些列主要是一些外键，可以加快连接的速度; (4) 在经常需要根据范围进行搜索的列上创建索引，囚为索引已经排序，其指定的范围是连续的; (5) 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间: (6) 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 同样，对于有些列不应该创建索引。一般来说，**不应该创建索引**的这些列具有下列特点: (1) 对于那些在查询中很少使用的列不应该创建索引。这是因为，既然这些列很少使用到，因此有无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度，增大了空间需求。 (2) 对于那些只有很少数据值的列也不应该创建索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占据了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 (3) 对于那些定义为text和bit等数据类型的列不应该创建索引。这是因为，这些列的数据量要么相当大，要么取值很少，不利于使用索引。 (4) 当修改操作远远大于检索操作时，不应该创建索引。这是因为，修改性能和检索性能是互相相矛盾的。当增加索引时，会提高检索的性能，但是会降低修改的性能。当减少索引时，会提高修改的性能，降低检索的性能。因此，当修改操作远远多于检索操作时，不应该创建索引。

**红黑树**等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：

（一）更少的查找次数。平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。

（二）利用磁盘预读特性。为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。

**数据库事务四大特性：**

ACID atomicity consistency isolation durability

原子性，一致性，隔离性，持久性

**数据库事务隔离四个级别：**

**Read uncommitted读未提交**：最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）

**Read committed读已提交**：一个事务提交后才能被其他事务读取到（会出现幻读、不可重复读）

**Repeatable read可重复读**：默认级别，保证多次读取同一数据内容一致，禁止读取事务未提交的数据（会出现幻读）

**Serializable串行化**：代价最高最可靠的隔离级别，防止脏读、幻读、不可重复读。

**数据库三范式：**

第一范式：如果关系模式R的每个关系r的属性都是不可分的数据项。每一个属性都是原子项，不可分割。

第二范式：如果关系模式R是1NF，且每个非主键属性完全函数依赖于候选键

第三范式：满足第二范式（2NF）。要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。任何非主键直接依赖其主键，不存在传递关系。

**数据库的五大约束：**

1主键约束 2唯一约束 3默认约束 4检查约束 5外键约束

**脏读，幻读，不可重复读的区别：**

**脏读**：表示一个事务能够读取另一个事务中还未提交的数据。

**幻读**：表示同一个事物内多次查询返回的结果集不一样。

**不可重复读**：表示在一个事务内，多次读同一数据。

**数据库的优化：**

首先知道数据量有多大

1数据预处理 2SQL语句优化 3添加索引和优化 4数据库引擎innoDB，myisam 5读写分离 6分表分区 7分布式数据库 8加缓存

INNODB 支持事务ACID，支持外键，行锁，查表总行数时，全表扫描。（适合读少写多）

MYISAM 不支持事务，不支持外键，表锁，插入数据时，锁定整个表，保存表的总行数。索引和数据分离。效率优于innoDB。（适合读多写少）

**MySQL的行锁和表锁：**

表级锁：开销小，加锁快，不会出现死锁。锁粒度大，并发量低。（MyIASM）

行级锁：开销大，加锁慢，会出现死锁。锁粒度小，并发度高。(InnoDB)

[**乐观锁和悲观锁的区别：**](https://blog.csdn.net/qq_34337272/article/details/81072874)

**乐观锁使用版本号机制或CAS算法实现。**

**乐观锁：**每次去拿数据的时候都认为别人不会去修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。

**悲观锁：**每次去拿数据的时候都认为别人会修改数据，所以每次取数据时都会上锁，直到这个锁被释放。

**数据库加锁**：行级锁，表级锁，乐观锁，悲观锁。共享锁，排它锁。

**MySql的内连接、左连接、右连接的区别：**

inner join; left join; right join;

**内连接**（使用像 = 或 <> 之类的比较运算符）是把匹配的关联数据显示出来，两表的交集；

使用比较运算符根据每个表共有的列的值匹配两个表中的行

**外连接**分为左外连接，右外连接，完整外连接

左连接是以左表为参照，显示所有数据；

右连接是以右表为参照，显示所有数据；

联接列所匹配的行，如果左表的某行在右表中没有匹配行，则将为右表返回空值。

**交叉联接**返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。

**聚簇索引和非聚簇索引的差异性:**

\- 在聚簇索引中，索引树的叶级页包含实际的数据：记录的索引顺序与物理顺序相同。聚簇索引非常象目录表，目录表的顺序与实际的页码顺序是一致的。

\- 在非聚簇索引中，叶级页指向表中的记录：记录的物理顺序与逻辑顺序没有必然的联系。非聚簇索引则更象书的标准索引表，索引表中的顺序通常与实际的页码顺序是不一致的。一本书也许有多个索引。例如，它也许同时有主题索引和作者索引。同样，一个表可以有多个非聚簇索引。 

**Redis内存性数据库 key-value非关系数据库，数据保存内存中，速度快，**

string list set hash sorted-set

支持事务

**MongoDB文档性数据库 存放xml,json,bson**

不支持事务

**关系型数据库**Oracle Mysql SQLServer DB2 PostgreSQL SQLite Teradata Access MariaDB SAP

**非关系型数据库**Redis MongoDB Cassandra Hbase MemcacheDB

**分布式：**

**CAP**:

Consistency一致性：读操作能返回最新的写操作

Availability可用性：非故障的节点在合理的时间内返回合理的响应

Partition Tolerance分区容错性：当出现网络分区后，系统能够继续工作

**分布式事务：**

为了保证不同数据库的数据一致性。

**1两阶段提交2PC**：第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并投票是否可以提交. 第二阶段：事务协调器要求每个数据库提交数据。**2补偿事务TCC** 采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：Try 阶段主要是对业务系统做检测及资源预留；Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功；Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释。**3****本地消息表：**核心思想是将分布式事务拆分成本地事务进行处理。**4****MQ事务消息**第一阶段Prepared消息，会拿到消息的地址。第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。

**分布式锁：**基于数据库实现分布式锁； 基于缓存（Redis等）实现分布式锁； 基于Zookeeper实现分布式锁；

[**JDBC 驱动程序类型**](https://www.jianshu.com/p/fce9ac03a250)

**Redis持久化**

RDB(Redis DataBase) 和AOF(Append Only File)

**RDB** 默认持久化方案，在指定时间间隔内，指定次数写操作。将内存数据作快照文件写入磁盘中，即在指定目录下生成一个dump.rdb文件，Redis重启会通过加载rdb文件恢复数据。

优点：

1 适合大规模的数据恢复。

2 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。

缺点：

1 数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。

2 备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。

所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。

**AOF** 默认不开启，弥补RDB。采用日志的形式来记录每个写操作，并追加到文件中。Redis重启会根据日志文件内容将写指令从前到后执行一次以完成数据的恢复工作。

优点：数据的完整性和一致性更高

缺点：因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。

**总结**

1. Redis 默认开启RDB持久化方式，在指定的时间间隔内，执行指定次数的写操作，则将内存中的数据写入到磁盘中。
2. RDB 持久化适合大规模的数据恢复但它的数据一致性和完整性较差。
3. Redis 需要手动开启AOF持久化方式，默认是每秒将写操作日志追加到AOF文件中。
4. AOF 的数据完整性比RDB高，但记录内容多了，会影响数据恢复的效率。
5. Redis 针对 AOF文件大的问题，提供重写的瘦身机制。
6. 若只打算用Redis 做缓存，可以关闭持久化。
7. 若打算使用Redis 的持久化。建议RDB和AOF都开启。其实RDB更适合做数据的备份，留一后手。AOF出问题了，还有RDB

[浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程。](#2778-1574143139068)

[HTTPS和HTTP的区别：](#7969-1572967515490)

[网络体系结构协议：](#76xudp1535002916207)

[TCP和UDP的区别：](#50mqzd1534412681836)

[Session和Cookie的区别：](#1077-1562941461274)

[Get和Post的区别：](#5465-1562941453477)

[TCP三次握手：](#7756-1572968029691)

[HTTP错误码](#17cbgm1534412681836)

[爬虫的基本流程](#84cxrj1554949700075)

[HTTP请求：](#9494-1573007320596)

[两个主机之间如何通信](#9874-1539566801008)

[对称加密与非对称加密](#7476-1539566801180)

[端口号](#34ijyw1541472433089)

[Servlet:](#3813-1573006809680)

**浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程。**

1.DNS解析 2.TCP连接 3.发送HTTP请求 4.服务器处理请求并返回HTTP报文 5.浏览器解析渲染页面

**HTTPS和HTTP的区别：**

　　1、http是超文本传输协议，信息是明文传输，数据未加密，https则是具有安全性的**ssl加密**传输协议。

　　2、https协议需要到**CA申请证书**，一般免费证书较少，因而需要一定费用。

　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是**80**，后者是**443**。

　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全，但更消耗资源。

Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。

**网络体系结构协议：**

![img](https:////note.youdao.com/src/8EE2BE7F3AEE4A6E9D9C82DE92E2F999)

**TCP和UDP的区别：**

**TCP**面向连接，提供可靠的服务。每一条TCP连接只能是点到点的。面向字节流。全双工的可靠信道。TCP通过三次握手建立连接确认、滑动窗口、超时重传、拥塞控制等机制实现可靠传输，数据传完，断开连接来节约资源。

缺点：慢，效率低，占用资源高，易被攻击

**UDP**是无连接的即发送数据之前不需要建立连接，尽最大努力交付，不保证可靠交付。面向报文。

UDP支持一对一，一对多，多对一和多对多的交互通信。UDP快，具有较好的实时性，工作效率比TCP高。适用于媒体通信/广播通信。

缺点：不可靠，不稳定，UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。

**Session和Cookie的区别：**

1. 存储位置不同。cookie数据存在客户浏览器上，session数据放在服务器上。
2. 安全性不同。cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。
3. 容量和个数限制。单个cookie保存的数据不能超过4K，浏览器限制一个站点最多保存20个cookie。session会在一定时间内保存在服务器上访问过多增加服务器压力。
4. 存储的多样性：session可以存储在Redis中、数据库中、应用程序中，而cookie只能存储在浏览器中。
5. 将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中

**Get****和****Post****的区别：**

**GET**请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的**select**操作一样，只是用来**查询**一下数据，不会修改、增加数据，不会影响资源的内容。**参数通过URL传递**，有**长度限制**。**不安全**。请求会被浏览器主动缓存。

**POST**请求是向服务器端发送数据的，但是该请求会**改变数据**的种类等资源，就像数据库的**insert**操作一样，会创建新的内容。参数传输更**安全**。

**TCP三次握手：**

![img](https:////note.youdao.com/src/BB74EB155F76422A8023A6D2A2D6813F)

**HTTP错误码**

400（错误请求） 服务器不理解请求的语法。

401（未授权）     请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。

403（禁止）         服务器拒绝请求。

404（未找到）     服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。

500（服务器内部错误）服务器遇到错误，无法完成请求。

501（未实现）服务器不支持实现此请求所需的功能。

502（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。

503（服务不可用）服务器目前无法使用（由于超载或停机维护）。

**爬虫的基本流程**

![img](https:////note.youdao.com/src/DEDE16467391448F95D5A92AAD5B57DF)

scrapy+redis分布式爬取，Web框架 Django，Flask，Bottle

HTTP 的header：通用头、请求头、响应头

网络爬虫所用到的网络数据包 requests,urllib2,urllib

网络爬虫所用到的解析数据包beautifulsoup, xpath

**反爬虫**

1.通过headers反爬虫

2.基于用户行为的发爬虫：(同一IP短时间内访问的频率)

3.动态网页反爬虫(通过ajax请求数据，或者通过JavaScript生成)

4.对部分数据进行加密处理的(数据是乱码)

解决方法：

对于基本网页的抓取可以自定义headers,添加headers的数据

使用多个代理ip进行抓取或者设置抓取的频率降低一些，

动态网页的可以使用selenium + phantomjs 进行抓取

对部分数据进行加密的，可以使用selenium进行截图，使用python自带的pytesseract库进行识别，但是比较慢最直接的方法是找到加密的方法进行逆向推理。

**HTTP请求：**

**GET**请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的select操作一样，只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容。参数通过URL传递，有长度限制。不安全。

**PUT**请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等。参数在RequestBody中。

**POST**请求是向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的insert操作一样，会创建新的内容。

**DELETE**请求是用来删除某一个资源的，该请求就像数据库的delete操作。

**GET和POST本质上都是TCP链接**

![img](https:////note.youdao.com/src/2D169BA36F3946ACAAB2ADD4ED8D8402)

![img](https:////note.youdao.com/src/C82188A6D901492395C653938A273A19)

**SYN攻击原理**

SYN攻击属于DOS攻击的一种，它利用TCP协议缺陷，通过发送大量的半连接请求，耗费CPU和内存资源。SYN攻击除了能影响主机外，还可以危害路由器、防火墙等网络系统，事实上SYN攻击并不管目标是什么系统，

只要这些系统打开TCP服务就可以实施。

**两个主机之间如何通信**

**同一局域网**内通信：用ARP来解决

地址解析协议ARP解决这个问题的方法是在主机ARP高速缓存中应存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常更新动态。每一个主机都设有一个ARP高速缓存，里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。

**不同局域网**内通信：用ARP和路由器来解决

假设主机A到主机B的通信路径是：主机A（网1）->路由器R1->主机P（网2）->路由器R2->主机B（网3）

1、主机A发送给主机B的IP数据报时，首先A发送ARP请求分组（在网1上广播），找到网1上的路由器R1的硬件地址，剩下的工作由R1来完成。

2、R1把IP数据报转发到网3上的主机B。B与R1不在一个网络，此时R1发送ARP请求分组（在网2上广播），找到连接在网2上的R2的硬件地址，剩下的工作由R2来完成。

3、R2把IP数据报转发到同一网络的主机B，此时R1发送ARP请求分组（在网2上广播），找到目的主机B的硬件地址。

**对称加密与非对称加密**

**对称加密**：加解密使用同一密钥，不安全。DES，IDEA，AES

**非对称加密**：公钥加密，私钥解密；公钥可以公开给别人进行加密，私钥永远在自己手里，非常安全。适用分布式系统数据加密，RSA，DSA

常用的对称加密算法有：DES、3DES、RC2、RC4、AES

常用的非对称加密算法有：RSA、DSA、ECC

使用单向散列函数的加密算法：MD5、SHA

**端口号**

1.HTTP协议代理服务器常用端口号：80/8080/3128/8081/9098 

HTTP服务器默认端口号为80/tcp HTTPS服务器默认端口号为443/tcp 443/udp

2.SOCKS代理协议服务器常用端口号：1080

3.FTP（文件传输）协议代理服务器常用端口号：21

4.Telnet（远程登录）协议代理服务器常用端口号：23

**Servlet:**

是运行在web服务器或者应用服务器上的程序，

servlet生命周期可以被定义为从创建知道毁灭的整个过程，

1Servlet通过调用init()方法进行初始化

2调用service()方法来处理客户端的请求

3调用destroy()方法中止结束

4servlet由JVM的垃圾回收器进行GC

Servlet单实例多线程机制

Servlet采用多线程来处理多个请求同时访问。servlet依赖于一个线程池来服务请求。

**servlet与jsp的区别**

1.jsp经编译后就变成了Servlet.(JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码,Web容器将JSP的代码编译成JVM能够识别的java类)

2.jsp更擅长表现于页面显示,servlet更擅长于逻辑控制.

3.Servlet中没有内置对象，内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到.Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。

4.对于静态HTML标签，Servlet都必须使用页面输出流逐行输出



[**设计模式深入理解**](https://www.cnblogs.com/foryang/p/5849402.html)

**单例模式：**

定义：单例对象的类只能允许一个实例存在

**饿汉式：**就是在第一次引用该类的时候就创建对象实例，而不管实际是否需要创建。缺点：无法实现对象延时加载。

public static class Singleton {    private Singleton() {}    private static Singleton instance = new Singleton();    public static Singleton getInstance() {        return instance;    } }

  在类装载的时候就完成实例化。避免了线程同步问题，但没有达到lazyloading的效果。线程不安全

public class Singleton {    private Singleton() {}        private static Singleton instance;    static {        instance = new Singleton();    }    public static Singleton getInstance() {        return instance;    } }

**懒汉式：**懒汉式就是需要使用该类的时候再创建对象实例（进而实现了对象的延时加载，减少了系统负荷）

单线程，不安全，如果有多条线程同时调用getSingleton()方法，就有很大可能导致重复创建对象。

public class LazySingleton {    private LazySingleton(){}    private static LazySingleton instance = null;    public static LazySingleton getInstance(){        if(instance == null){            instance = new LazySingleton();        }        return instance;    } }

  双重检查加锁：使用双判断null方式，可以减少线程进行等待，提高效率。

public class Singleton {    private Singleton(){}    private volatile static Singleton instance = null;    public static Singleton getInstance(){        if(instance == null){            synchronized (Singleton.class) {                if(instance == null){                    instance = new Singleton();                }            }        }        return instance;    } }

**单例模式**：保证被创建一次，节省系统开销。

**三种工厂模式之间的区别**

**1.简单工厂模式**：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。

简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。

**2.工厂方法模型**：用来生产同一等级结构中的固定产品，支持增加任意产品。

通过定义一个抽象的核心工厂类，并定义创建产品对象的接口，创建具体产品实例的工作延迟到其工厂子类去完成。这样做的好处是核心类只关注工厂类的接口定义，而具体的产品实例交给具体的工厂子类去创建。当系统需要新增一个产品时，无需修改现有系统代码，只需要添加一个具体产品类和其对应的工厂子类，使系统的扩展性变得很好，符合面向对象编程的开闭原则。鼠标工厂父类有生产鼠标这个接口，戴尔鼠标工厂生产戴尔鼠标，联想鼠标工厂生产联想鼠标。所以是一个抽象产品类，派生出多个具体产品类；一个抽象工厂类，派生出多个具体工厂类。

**3.抽象工厂模式**：用来生产不同产品族的全部产品，对于增加新的产品无能为力；支持增加产品族。

定义一个创建一系列相关或者相互依赖对象的工厂接口，然后每个子类工厂创建自己的一系列实例类。如果需要一个具体的工厂生产多种产品对象，那么就需要用到抽象工厂模式。比如有一个生产键盘和鼠标的工厂接口，然后戴尔工厂类生产戴尔牌键盘和鼠标，联想工厂类生产联想牌键盘和鼠标。所以是多个抽象产品类，每个抽象产品类派生出多个具体产品类；多个抽象工厂类，派生出多个具体工厂类。

- 工厂方法模式利用继承，抽象工厂模式利用组合
- 工厂方法模式产生一个对象，抽象工厂模式产生一系列对象
- 工厂方法模式利用子类创造对象，抽象工厂模式利用接口的实现创造对象