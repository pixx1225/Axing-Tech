[TOC]

# 从0开始学架构

## 基础架构

### 架构到底是什么？

- 系统与子系统

> 系统泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体。它的意思是“总体”“整体”或“联盟”。

> 子系统也是由一群有关联的个体所组成的系统，多半会是更大系统中的一部分。

- 模块与组件

> 软件模块（Module）是一套一致而互相有紧密关连的软件组织。它分别包含了程序和数据结构两部分。现代软件开发往往利用模块作为合成的单位。模块的接口表达了由该模块提供的功能和调用它时所需的元素。模块是可能分开被编写的单位。这使它们可再用和允许人员同时协作、编写及研究不同的模块。

> 软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被用于组装应用程序中。

模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已。

- 框架与架构

> 软件框架（Software framework）通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。

**框架关注的是“规范”，架构关注的是“结构”**。

框架的英文是 Framework，架构的英文是 Architecture。

我将架构重新定义为：**软件架构指软件系统的顶层结构。**



### 架构设计的历史背景

- 机器语言

机器语言的主要问题是三难：太难写、太难读、太难改！

- 汇编语言

汇编语言又叫“符号语言”，用助记符代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。

汇编语言虽然解决了机器语言读写复杂的问题，但本质上还是面向机器的，因为写汇编语言需要我们精确了解计算机底层的知识。

- 高级语言

让程序员不需要关注机器底层的低级结构和逻辑，而只要关注具体的问题和业务即可。

- 第一次软件危机与结构化程序设计
- 第二次软件危机与面向对象

面向对象真正开始流行是在 20 世纪 80 年代，主要得益于 C++ 的功劳，后来的 Java、C# 把面向对象推向了新的高峰。到现在为止，面向对象已经成为了主流的开发思想。

### 架构设计的目的

架构设计的主要目的是为了解决软件系统复杂度带来的问题。

### 复杂度的来源

#### 高性能

软件系统中高性能带来的复杂度主要体现在两方面，一方面是单台计算机内部为了高性能带来的复杂度；另一方面是多台计算机集群为了高性能带来的复杂度。

如何做好高性能？可以从垂直与水平两个维度来考虑。垂直维度主要是针对单台计算机，通过升级软、硬件能力实现性能提升；水平维度则主要针对集群系统，利用合理的任务分配与任务分解实现性能的提升。

#### 高可用

> 系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。

高可用的“**冗余**”解决方案，单纯从形式上来看，和之前讲的高性能是一样的，都是通过增加更多机器来达到目的，但其实本质上是有根本区别的：**高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元。**

- 计算高可用

“计算”指的是业务的逻辑处理。计算有一个特点就是**无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的**，所以将计算从一台机器迁移到另外一台机器，对业务并没有什么影响。

任务分配器需要增加分配算法。例如，常见的双机算法有主备、主主，主备方案又可以细分为冷备、温备、热备。ZooKeeper 采用的就是 1 主多备，而 Memcached 采用的就是全主 0 备。

- 存储高可用

存储与计算相比，有一个本质上的区别：**将数据从一台机器搬到到另一台机器，需要经过线路进行传输。**

**存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响。**

分布式领域里面有一个著名的 CAP 定理，从理论上论证了存储高可用的复杂度。也就是说，存储高可用不可能同时满足“一致性、可用性、分区容错性”，最多满足其中两个，这就要求我们在做架构设计时结合业务进行取舍。

- 高可用状态决策

无论是计算高可用还是存储高可用，其基础都是“**状态决策**”，即系统需要能够判断当前的状态是正常还是异常，如果出现了异常就要采取行动来保证高可用。**通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确。**

**1.独裁式**，独裁式决策指的是存在一个独立的决策主体

**2.协商式**，协商式决策指的是两个独立的个体通过交流信息，然后根据规则进行决策，最常用的协商式决策就是**主备**决策。

**3.民主式**，决策指的是多个独立的个体通过投票的方式来进行状态决策。例如，ZooKeeper 集群在选举 leader 时就是采用这种方式。为了解决脑裂问题，民主式决策的系统一般都采用“**投票节点数必须超过系统总节点数一半**”规则来处理。

#### 可扩展性

设计具备良好可扩展性的系统，有两个基本条件：**正确预测变化、完美封装变化**

第一种常见的应对变化的常见方案是**将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”**。第二种常见的应对变化的方案是**提炼出一个“抽象层”和一个“实现层”。**

#### 低成本、安全、规模

- 低成本

低成本给架构设计带来的主要复杂度体现在，**往往只有“创新”才能达到低成本目标。**

- 安全

功能安全其实就是“防小偷”。架构安全就是“防强盗”。传统的架构安全主要依靠**防火墙**，防火墙最基本的功能就是隔离网络，通过将网络划分成不同的区域，制定出不同区域之间的访问控制策略来控制不同信任程度区域间传送的数据流。

- 规模

规模带来复杂度的主要原因就是“**量变引起质变**”。1. 功能越来越多，导致系统复杂度指数级上升。2. 数据越来越多，系统复杂度发生质变

### 架构设计三原则

合适原则、简单原则、演化原则

面对“不确定性”时架构设计的三原则，分别是合适优于业界领先、简单优于复杂、演化优于一步到位

### 架构设计流程

- 识别复杂度

正确的做法是将主要的复杂度问题列出来，然后根据业务、技术、团队等综合情况进行排序，优先解决当前面临的最主要的复杂度问题。

- 设计备选方案

第一种常见的错误：设计最优秀的方案。根据架构设计原则中“合适原则”和“简单原则“的要求，挑选合适自己业务、团队、技术能力的方案才是好方案；否则要么浪费大量资源开发了无用的系统。

第二种常见的错误：只做一个方案。备选方案的数量以 3 ~ 5 个为最佳。备选方案的差异要比较明显。备选方案的技术不要只局限于已经熟悉的技术。

第三种常见的错误：备选方案过于详细。正确的做法是备选阶段关注的是技术选型，而不是技术细节，技术选型的差异要比较明显。

- 评估和选择备选方案

列出我们需要关注的质量属性点，然后分别从这些质量属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案。常见的方案质量属性点有：性能、可用性、硬件成本、项目投入、复杂度、安全性、可扩展性等。

- 详细方案设计

详细设计方案阶段可能遇到的一种极端情况就是在详细设计阶段发现备选方案不可行，一般情况下主要的原因是备选方案设计时遗漏了某个关键技术点或者关键的质量属性。架构师不但要进行备选方案设计和选型，还需要对备选方案的关键细节有较深入的理解。通过分步骤、分阶段、分系统等方式，尽量降低方案复杂度。如果方案本身就很复杂，那就采取设计团队的方式来进行设计，博采众长，汇集大家的智慧和经验。



## 高性能架构模式

### 高性能数据库集群：读写分离

高性能数据库集群的第一种方式是“读写分离”，其本质是将访问压力分散到集群中的多个节点，但是没有分散存储压力；第二种方式是“分库分表”，既可以分散访问压力，又可以分散存储压力。

**读写分离**的基本原理是将数据库读写操作分散到不同的节点上。

![img](https://static001.geekbang.org/resource/image/36/07/362d22168bf344687ec0c206aa115807.jpg)

读写分离的基本实现是：

- 数据库服务器搭建主从集群，一主一从、一主多从都可以。
- 数据库主机负责读写操作，从机只负责读操作。
- 数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。
- 业务服务器将写操作发给数据库主机，将读操作发给数据库从机。

读写分离的实现逻辑并不复杂，但有两个细节点将引入设计复杂度：**主从复制延迟和分配机制**。

解决主从**复制延迟**有几种常见的方法：

1. 写操作后的读操作指定发给数据库主服务器

2. 读从机失败后再读一次主机
3. 关键业务读写操作全部指向主机，非关键业务采用读写分离

将读写操作区分开来，然后访问不同的数据库服务器，一般有两种方式：**程序代码封装**和**中间件封装**。

### 高性能数据库集群：分库分表

**业务分库**指的是按照业务模块将数据分散到不同的数据库服务器。

1.join 操作问题。2. 事务问题。3. 成本问题

**分表**：单表数据拆分有两种方式：垂直分表和水平分表

垂直分表适合将表中某些不常用且占了大量空间的列拆分出去。垂直分表引入的复杂性主要体现在表操作的数量要增加。

水平分表适合表行数特别大的表，1.路由。2.join 操作。3.count() 操作。4.order by 操作

### 高性能NoSQL

关系数据库存在如下缺点：

1. 关系数据库存储的是行记录，无法存储数据结构
2. 关系数据库的 schema 扩展很不方便
3. 关系数据库在大数据场景下 I/O 较高
4. 关系数据库的全文搜索功能比较弱

常见的 NoSQL 方案分为 4 类。

- K-V 存储：解决关系数据库无法存储数据结构的问题，以 Redis 为代表。
- 文档数据库：解决关系数据库强 schema 约束的问题，以 MongoDB 为代表。
- 列式数据库：解决关系数据库大数据场景下的 I/O 问题，以 HBase 为代表。
- 全文搜索引擎：解决关系数据库的全文搜索性能问题，以 Elasticsearch 为代表。

Redis 的缺点主要体现在并不支持完整的 ACID 事务，Redis 虽然提供事务功能，但 Redis 的事务和关系数据库的事务不可同日而语，Redis 的事务只能保证隔离性和一致性（I 和 C），无法保证原子性和持久性（A 和 D）。

文档数据库的缺点就是不支持事务，还有无法实现关系数据库的 join 操作。

列式存储的随机写效率要远远低于行式存储的写效率。此外，列式存储高压缩率在更新场景下也会成为劣势，因为更新时需要将存储数据解压后更新，然后再压缩，最后写入磁盘。

### 高性能缓存架构

**缓存穿透**是指缓存没有发挥作用，业务系统虽然去缓存查询数据，但缓存中没有数据，业务系统需要再次去存储系统查询数据。通常情况下有两种情况：1. 存储数据不存在。2. 缓存数据生成耗费大量时间或者资源。

**缓存雪崩**是指当缓存失效（过期）后引起系统性能急剧下降的情况。缓存雪崩的常见解决方法有两种：更新锁机制和后台更新机制。

**缓存热点**的解决方案就是复制多份缓存副本，将请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力。

### 单服务器高性能模式：PPC与TPC

单服务器高性能的关键之一就是服务器采取的并发模型，并发模型有如下两个关键设计点：

- 服务器如何管理连接。
- 服务器如何处理请求。

以上两个设计点最终都和操作系统的 I/O 模型及进程模型相关。

- I/O 模型：阻塞、非阻塞、同步、异步。
- 进程模型：单进程、多进程、多线程。

**PPC** 是 Process Per Connection 的缩写，其含义是指每次有新的连接就新建一个进程去专门处理这个连接的请求，这是传统的 UNIX 网络服务器所采用的模型。prefork 是提前创建进程（pre-fork）。系统在启动的时候就预先创建好进程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去 fork 进程的操作，让用户访问更快、体验更好。

**TPC** 是 Thread Per Connection 的缩写，其含义是指每次有新的连接就新建一个线程去专门处理这个连接的请求。与进程相比，线程更轻量级，创建线程的消耗比进程要少得多；同时多线程是共享进程内存空间的，线程通信相比进程通信更简单。和 prefork 类似，prethread 模式会预先创建线程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去创建线程的操作，让用户感觉更快、体验更好。

### 单服务器高性能模式：Reactor与Proactor

**Reactor** 模式也叫 Dispatcher 模式，即 I/O 多路复用统一监听事件，收到事件后分配（Dispatch）给某个进程。Reactor 模式的核心组成部分包括 Reactor 和处理资源池（进程池或线程池），其中 Reactor 负责监听和分配事件，处理资源池负责处理事件。

Reactor 模式有这三种典型的实现方案：

- 单 Reactor 单进程 / 线程。Redis。
- 单 Reactor 多线程。
- 多 Reactor 多进程 / 线程。Nginx 采用的是多 Reactor 多进程。多 Reactor 多线程的实现有 Memcache 和 Netty。

Reactor 是非阻塞同步网络模型，Proactor是非阻塞异步网络模型。可以通Reactor 通俗地理解为“来了一个事件我就有相应的反应”，Proactor 可以理解为“来了事件我来处理，处理完了我通知你”

### 高性能负载均衡：分类及架构

高性能集群的复杂性主要体现在需要增加一个任务分配器，以及为任务选择一个合适的任务分配算法。

常见的负载均衡系统包括 3 种：DNS 负载均衡、硬件负载均衡和软件负载均衡。

**DNS 负载均衡**，一般用来实现地理级别的均衡。优点：简单，成本低、就近访问，提升访问速度。缺点：更新不及时、扩展性差、分配策略比较简单。

**硬件负载均衡**，通过单独的硬件设备来实现负载均衡功能，这类设备和路由器、交换机类似，可以理解为一个用于负载均衡的基础网络设备。目前业界典型的硬件负载均衡设备有两款：F5 和 A10。优点：功能强大、性能强大、稳定性高、支持安全防护。缺点：价格昂贵、扩展能力差。

**软件负载均衡**，通过负载均衡软件来实现负载均衡功能，常见的有 Nginx 和 LVS，其中 Nginx 是软件的 7 层负载均衡，LVS 是 Linux 内核的 4 层负载均衡。优点：简单、便宜、灵活。缺点：性能一般、功能没有硬负载强大、一般不具备防火墙和防 DDoS 攻击等安全功能。

**组合的基本原则**为：DNS 负载均衡用于实现地理级别的负载均衡；硬件负载均衡用于实现集群级别的负载均衡；软件负载均衡用于实现机器级别的负载均衡。

![img](https://static001.geekbang.org/resource/image/79/8d/79f371ecbf74818e2a34b4a31664668d.png)

### 高性能负载均衡：算法

**轮询**：负载均衡系统收到请求后，按照顺序轮流分配到服务器上。轮询是最简单的一个策略，无须关注服务器本身的状态。

**加权轮询**：负载均衡系统根据服务器权重进行任务分配，这里的权重一般是根据硬件配置进行静态配置的，采用动态的方式计算会更加契合业务，但复杂度也会更高。加权轮询是轮询的一种特殊形式，其主要目的就是为了解决不同服务器处理能力有差异的问题。

**负载最低优先**：负载均衡系统将任务分配给当前负载最低的服务器，这里的负载根据不同的任务类型和业务场景，可以用不同的指标来衡量。

**性能最优类**：负载最低优先类算法是站在服务器的角度来进行分配的，而性能最优优先类算法则是站在客户端的角度来进行分配的，优先将任务分配给处理速度最快的服务器，通过这种方式达到最快响应客户端的目的。和负载最低优先类算法类似，性能最优优先类算法本质上也是感知了服务器的状态，只是通过响应时间这个外部标准来衡量服务器状态而已。因此性能最优优先类算法存在的问题和负载最低优先类算法类似，复杂度都很高。

**Hash 类**：负载均衡系统根据任务中的某些关键信息进行 Hash 运算，将相同 Hash 值的请求分配到同一台服务器上，这样做的目的主要是为了满足特定的业务需求。例如：源地址 Hash、ID Hash。

## 高可用架构模式

### CAP理论

对于一个分布式计算系统，不可能同时满足一致性（Consistence）、可用性（Availability）、分区容错性（Partition Tolerance）三个设计约束。

在一个分布式系统（指互相连接并共享数据的节点的集合）中，当涉及**读写操作**时，只能保证一致性（C）、可用性（A）、分区容错性（P）三者中的两个，另外一个必须被牺牲。

```
一致性（Consistency）：对某个指定的客户端来说，读操作保证能够返回最新的写操作结果。
可用性（Availability）：非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应）。
分区容忍性（Partition Tolerance）：当出现网络分区后，系统能够继续“履行职责”。
```

分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。

CAP 关注的粒度是数据，而不是整个系统。

CAP 是忽略网络延迟的。

正常运行情况下，不存在 CP 和 AP 的选择，可以同时满足 CA。

放弃并不等于什么都不做，需要为分区恢复后做准备。

ACID：Atomicity（原子性）Consistency（一致性）Isolation（隔离性）Durability（持久性），数据库管理系统为了保证事务的正确性而提出来的一个理论

BASE ：基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency），核心思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性。