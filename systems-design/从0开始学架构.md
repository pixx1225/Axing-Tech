[TOC]

# 从0开始学架构

## 基础架构

### 架构到底是什么？

- 系统与子系统

> 系统泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体。它的意思是“总体”“整体”或“联盟”。

> 子系统也是由一群有关联的个体所组成的系统，多半会是更大系统中的一部分。

- 模块与组件

> 软件模块（Module）是一套一致而互相有紧密关连的软件组织。它分别包含了程序和数据结构两部分。现代软件开发往往利用模块作为合成的单位。模块的接口表达了由该模块提供的功能和调用它时所需的元素。模块是可能分开被编写的单位。这使它们可再用和允许人员同时协作、编写及研究不同的模块。

> 软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被用于组装应用程序中。

模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已。

- 框架与架构

> 软件框架（Software framework）通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。

**框架关注的是“规范”，架构关注的是“结构”**。

框架的英文是 Framework，架构的英文是 Architecture。

我将架构重新定义为：**软件架构指软件系统的顶层结构。**



### 架构设计的历史背景

- 机器语言

机器语言的主要问题是三难：太难写、太难读、太难改！

- 汇编语言

汇编语言又叫“符号语言”，用助记符代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。

汇编语言虽然解决了机器语言读写复杂的问题，但本质上还是面向机器的，因为写汇编语言需要我们精确了解计算机底层的知识。

- 高级语言

让程序员不需要关注机器底层的低级结构和逻辑，而只要关注具体的问题和业务即可。

- 第一次软件危机与结构化程序设计
- 第二次软件危机与面向对象

面向对象真正开始流行是在 20 世纪 80 年代，主要得益于 C++ 的功劳，后来的 Java、C# 把面向对象推向了新的高峰。到现在为止，面向对象已经成为了主流的开发思想。

### 架构设计的目的

架构设计的主要目的是为了解决软件系统复杂度带来的问题。

### 复杂度的来源

#### 高性能

软件系统中高性能带来的复杂度主要体现在两方面，一方面是单台计算机内部为了高性能带来的复杂度；另一方面是多台计算机集群为了高性能带来的复杂度。

如何做好高性能？可以从垂直与水平两个维度来考虑。垂直维度主要是针对单台计算机，通过升级软、硬件能力实现性能提升；水平维度则主要针对集群系统，利用合理的任务分配与任务分解实现性能的提升。

#### 高可用

> 系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。

高可用的“**冗余**”解决方案，单纯从形式上来看，和之前讲的高性能是一样的，都是通过增加更多机器来达到目的，但其实本质上是有根本区别的：**高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元。**

- 计算高可用

“计算”指的是业务的逻辑处理。计算有一个特点就是**无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的**，所以将计算从一台机器迁移到另外一台机器，对业务并没有什么影响。

任务分配器需要增加分配算法。例如，常见的双机算法有主备、主主，主备方案又可以细分为冷备、温备、热备。ZooKeeper 采用的就是 1 主多备，而 Memcached 采用的就是全主 0 备。

- 存储高可用

存储与计算相比，有一个本质上的区别：**将数据从一台机器搬到到另一台机器，需要经过线路进行传输。**

**存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响。**

分布式领域里面有一个著名的 CAP 定理，从理论上论证了存储高可用的复杂度。也就是说，存储高可用不可能同时满足“一致性、可用性、分区容错性”，最多满足其中两个，这就要求我们在做架构设计时结合业务进行取舍。

- 高可用状态决策

无论是计算高可用还是存储高可用，其基础都是“**状态决策**”，即系统需要能够判断当前的状态是正常还是异常，如果出现了异常就要采取行动来保证高可用。**通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确。**

**1.独裁式**，独裁式决策指的是存在一个独立的决策主体

**2.协商式**，协商式决策指的是两个独立的个体通过交流信息，然后根据规则进行决策，最常用的协商式决策就是**主备**决策。

**3.民主式**，决策指的是多个独立的个体通过投票的方式来进行状态决策。例如，ZooKeeper 集群在选举 leader 时就是采用这种方式。为了解决脑裂问题，民主式决策的系统一般都采用“**投票节点数必须超过系统总节点数一半**”规则来处理。

#### 可扩展性

设计具备良好可扩展性的系统，有两个基本条件：**正确预测变化、完美封装变化**

第一种常见的应对变化的常见方案是**将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”**。第二种常见的应对变化的方案是**提炼出一个“抽象层”和一个“实现层”。**

#### 低成本、安全、规模

- 低成本

低成本给架构设计带来的主要复杂度体现在，**往往只有“创新”才能达到低成本目标。**

- 安全

功能安全其实就是“防小偷”。架构安全就是“防强盗”。传统的架构安全主要依靠**防火墙**，防火墙最基本的功能就是隔离网络，通过将网络划分成不同的区域，制定出不同区域之间的访问控制策略来控制不同信任程度区域间传送的数据流。

- 规模

规模带来复杂度的主要原因就是“**量变引起质变**”。1. 功能越来越多，导致系统复杂度指数级上升。2. 数据越来越多，系统复杂度发生质变

### 架构设计三原则

合适原则、简单原则、演化原则

面对“不确定性”时架构设计的三原则，分别是合适优于业界领先、简单优于复杂、演化优于一步到位

### 架构设计流程

- 识别复杂度

正确的做法是将主要的复杂度问题列出来，然后根据业务、技术、团队等综合情况进行排序，优先解决当前面临的最主要的复杂度问题。

- 设计备选方案

第一种常见的错误：设计最优秀的方案。根据架构设计原则中“合适原则”和“简单原则“的要求，挑选合适自己业务、团队、技术能力的方案才是好方案；否则要么浪费大量资源开发了无用的系统。

第二种常见的错误：只做一个方案。备选方案的数量以 3 ~ 5 个为最佳。备选方案的差异要比较明显。备选方案的技术不要只局限于已经熟悉的技术。

第三种常见的错误：备选方案过于详细。正确的做法是备选阶段关注的是技术选型，而不是技术细节，技术选型的差异要比较明显。

- 评估和选择备选方案

列出我们需要关注的质量属性点，然后分别从这些质量属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案。常见的方案质量属性点有：性能、可用性、硬件成本、项目投入、复杂度、安全性、可扩展性等。

- 详细方案设计

详细设计方案阶段可能遇到的一种极端情况就是在详细设计阶段发现备选方案不可行，一般情况下主要的原因是备选方案设计时遗漏了某个关键技术点或者关键的质量属性。架构师不但要进行备选方案设计和选型，还需要对备选方案的关键细节有较深入的理解。通过分步骤、分阶段、分系统等方式，尽量降低方案复杂度。如果方案本身就很复杂，那就采取设计团队的方式来进行设计，博采众长，汇集大家的智慧和经验。



## 高性能架构模式

### 高性能数据库集群：读写分离

高性能数据库集群的第一种方式是“读写分离”，其本质是将访问压力分散到集群中的多个节点，但是没有分散存储压力；第二种方式是“分库分表”，既可以分散访问压力，又可以分散存储压力。

**读写分离**的基本原理是将数据库读写操作分散到不同的节点上。

![img](https://static001.geekbang.org/resource/image/36/07/362d22168bf344687ec0c206aa115807.jpg)

读写分离的基本实现是：

- 数据库服务器搭建主从集群，一主一从、一主多从都可以。
- 数据库主机负责读写操作，从机只负责读操作。
- 数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。
- 业务服务器将写操作发给数据库主机，将读操作发给数据库从机。

读写分离的实现逻辑并不复杂，但有两个细节点将引入设计复杂度：**主从复制延迟和分配机制**。

解决主从**复制延迟**有几种常见的方法：

1. 写操作后的读操作指定发给数据库主服务器

2. 读从机失败后再读一次主机
3. 关键业务读写操作全部指向主机，非关键业务采用读写分离

将读写操作区分开来，然后访问不同的数据库服务器，一般有两种方式：**程序代码封装**和**中间件封装**。

### 高性能数据库集群：分库分表

**业务分库**指的是按照业务模块将数据分散到不同的数据库服务器。

1.join 操作问题。2. 事务问题。3. 成本问题

**分表**：单表数据拆分有两种方式：垂直分表和水平分表

垂直分表适合将表中某些不常用且占了大量空间的列拆分出去。垂直分表引入的复杂性主要体现在表操作的数量要增加。

水平分表适合表行数特别大的表，1.路由。2.join 操作。3.count() 操作。4.order by 操作

