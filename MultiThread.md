[TOC]

# 多线程

## 基本概念
### 进程和线程的区别：
- 进程是系统进行资源分配和调度的基本单位
- 线程是程序执行的最小单位
- 一个程序至少有一个进程，一个进程至少有一个线程
- 每个进程有独立的代码和数据空间，进程切换开销大
- 同类线程共享代码和数据空间，有独立运行栈和程序计数器，切换开销小
- 进程间不会相互影响；一个线程挂掉会导致整个进程挂掉。

### 死锁的四个必要条件：
1. 互斥条件 2. 请求和保持条件 3. 不剥夺条件 4. 循环等待条件

### 进程间通信方式：
1. 管道pipe 半双工
2. 命名管道FIFO
3. 消息队列message queue
4. 信号量semophore PV操作
5. 共享内存shared memory
6. 套接字socket
7. 信号sinal

### 线程间通信方式：
wait()、notify()和notifyAll()。调用wait()方法可以使调用该方法的线程释放共享资源的锁，然后从运行态退出，进入等待队列，直到被再次唤醒。而调用notify()方法可以唤醒等待队列中第一个等待同一共享资源的线程，并使该线程退出等待队列，进入可运行态。调用notifyAll()方法可以使所有正在等待队列中等待同一共享资源的线程从等待状态退出，进入可运行状态，此时，优先级最高的那个线程最先执行。

### 创建线程的三种方式：
1. 继承Thread类
2. 实现Runable接口(推荐)
3. 使用Executor框架创建线程池
4. 通过Callable接口并实现call()方法，该call()方法将作为线程执行体，并且有返回值

### 线程同步的方式：
1. 同步方法，使用synchronized关键字修饰方法
2. 同步代码块，使用synchronized关键字修饰代码块
3. 使用特殊域变量volatile实现线程同步
4. 使用重入锁实现线程同步，ReentrantLock创建实例，lock()获得锁，unlock()释放锁
5. 使用局部变量实现线程同步，ThreadLocal() : 创建一个线程本地变量
6. 使用阻塞队列实现线程同步，BlockingQueue<E>定义了阻塞队列的常用方法，add(),offer(),put()
7. 使用原子变量实现线程同步,

# 线程安全

## Synchronize

- 同步普通方法，锁的是当前对象。
- 同步静态方法，锁的是当前 `Class` 对象。
- 同步块，锁的是 `{}` 中的对象。

**实现原理：** 
`JVM` 是通过进入、退出对象监视器( `Monitor` )来实现对方法、同步块的同步的。其本质就是对一个对象监视器( `Monitor` )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。

![image](https://github.com/pixx1225/Axing-Tech/blob/master/images/Monitor流程图.jpeg)

## Volatile

 **具有了以下两点特性：** 

- 1 . 保证了不同线程对该变量操作的**内存可见性**;
- 2 . 禁止指令**重排序**

## ThreadLocal 

### 基本概念

## 线程池

### 原理：
1. 线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则执行第二步。 
2. 线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里进行等待。如果工作队列满了，则执行第三步。
3. 线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。

### 优点：
1. 降低资源消耗 
可以重复利用已创建的线程降低线程创建和销毁造成的消耗。 
2. 提高响应速度 
当任务到达时，任务可以不需要等到线程创建就能立即执行。 
3. 提高线程的可管理性 
线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控
线程分为守护线程和非守护线程（即用户线程）。守护线程最典型的应用就是 GC (垃圾回收器)

### 4种常用线程池：
1. Executors.newCacheThreadPool()可缓存线程池：先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务。
2. Executors.newFixedThreadPool(int n)：创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。
3.  Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行
4.  Executors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
