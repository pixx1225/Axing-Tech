[TOC]

# 数据库知识总汇

## JDBC

### JDBC数据库连接的基本步骤：

1.加载JDBC驱动到JVM，将Driver类的实例注册到DriverManager类中

2.提供JDBC连接的URL，定义了连接数据库时的协议、子协议、数据源标识

3.创建数据库的连接，向java.sql.DriverManager请求并获得Connection对象

4.创建一个Statement

5.执行SQL语句，Statement接口提供了三种执行SQL语句的方法：executeQuery 、executeUpdate	和execute

6.获取并操作结果集，

7.关闭JDBC对象  

操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声明顺序相反：  

1、关闭记录集  2、关闭声明  3、关闭连接对象

```java
public static void main(String[] args){
  Connection conn = null;
  PreparedStatement ps = null;
  ResultSet rs = null;
  try{
    //加载数据库驱动
    Class.forName("com.mysql.jdbc.Driver");
    //通过驱动管理类获取数据库链接
    conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8","root","passport");
    //定义sql语句，？表示占位符
    String  sql = "select * from user where username = ?";
    //获取预处理statement
    ps = conn.prepareStatement(sql);
    //设置参数
    ps.setString(1,"王五");
    //向数据库发出sql执行查询，查询出结果集
    rs = ps.executeQuery();
    //遍历查询结果集
    while(rs.next()){
      System.out.println(rs.getString("id")+" "+rs.getString("username"));
    }
  }catch (Exception e){
    e.printStackTrace();
  }finally{
    //释放资源
    if(rs != null){
      try{
        rs.close();
      }catch(SQLException e){
        e.printStackTrace();
      }
    }
    if(ps != null){
      try{
        ps.close();
      }catch(SQLException e){
        e.printStackTrace();
      }
    }
    if(conn != null){
      try{
        conn.close();
      }catch(SQLException e){
        e.printStackTrace();
      }
    }
  }
}
```

## 查询语句SQL是如何执行的

![SQL查询语句执行流程](https://github.com/pixx1225/Axing-Tech/blob/master/images/SQL查询流程.png)

大体来说，MySQL可以分为`Server`层和`存储引擎`层两部分

* `Server`层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
* `存储引擎层`负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分

### 连接器

第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在`show processlist`命令中看到它。客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数`wait_timeout`控制的，默认值是`8`小时。数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。

### 查询缓存

MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。

如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。（大多数情况下不要使用查询缓存，因为查询缓存的失效非常频繁。）

### 分析器

首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。分析器先会做`“词法分析”`,词法分析完后就要做`“语法分析”`。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒

### 优化器

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。

> 比如你执行下面这样的语句，这个语句是执行两个表的join：
> `mysql> select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;`
> 既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。
> 也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。
> 这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。

### 执行器

MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误。如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。

> `mysql> select * from T where ID=10;`
> 比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：
> 调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；
> 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
> 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。



## 数据库索引

是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。**索引的实现通常使用B树及其变种B+树**。

### B+树

**优点**解答:创建索引可以大大提高系统的性能。 (1) 大大加快数据的检索速度，这也是创建索引的最主要原因。 (2) 创建唯一性索引，保证数据库表中每一行数据的唯一性。 (3) 加速表和表之间的连接。 (4) 在使用分组(group by)和排序(order by)子句进行数据检索时，可以显著减少查询中分组和排序的时间。 (5) 通过使用索引，可以在查询的过程中，使用查询优化器，提高系统的性能。 那么索引有如此多的优点，为什么不对表中的**每一个列创建一个索引**呢？这是因为增加索引也有许多不利的方面。 (1) 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 (2) 索引需要占用物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 (3) 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 一般来说，应该在这些列上**创建索引**: (1) 在经常需要搜索的列上创建索引，可以加快搜索的速度; (2) 在作为主键的列上创建索引，强制该列的唯一性和组织表中数据的排列结构; (3) 在经常用在连接的列上创建索引，这些列主要是一些外键，可以加快连接的速度; (4) 在经常需要根据范围进行搜索的列上创建索引，囚为索引已经排序，其指定的范围是连续的; (5) 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间: (6) 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 同样，对于有些列不应该创建索引。一般来说，**不应该创建索引**的这些列具有下列特点: (1) 对于那些在查询中很少使用的列不应该创建索引。这是因为，既然这些列很少使用到，因此有无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度，增大了空间需求。 (2) 对于那些只有很少数据值的列也不应该创建索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占据了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 (3) 对于那些定义为text和bit等数据类型的列不应该创建索引。这是因为，这些列的数据量要么相当大，要么取值很少，不利于使用索引。 (4) 当修改操作远远大于检索操作时，不应该创建索引。这是因为，修改性能和检索性能是互相相矛盾的。当增加索引时，会提高检索的性能，但是会降低修改的性能。当减少索引时，会提高修改的性能，降低检索的性能。因此，当修改操作远远多于检索操作时，不应该创建索引。

### 红黑树

等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：

（一）更少的查找次数。平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。

（二）利用磁盘预读特性。为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。

## 数据库事务

### 数据库事务四大特性：

ACID atomicity consistency isolation durability

原子性，一致性，隔离性，持久性

### 数据库事务隔离四个级别：

**Read uncommitted读未提交**：最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）

**Read committed读已提交**：一个事务提交后才能被其他事务读取到（会出现幻读、不可重复读）

**Repeatable read可重复读**：默认级别，保证多次读取同一数据内容一致，禁止读取事务未提交的数据（会出现幻读）

**Serializable串行化**：代价最高最可靠的隔离级别，防止脏读、幻读、不可重复读。

## 数据库三范式：

第一范式：如果关系模式R的每个关系r的属性都是不可分的数据项。每一个属性都是原子项，不可分割。

第二范式：如果关系模式R是1NF，且每个非主键属性完全函数依赖于候选键

第三范式：满足第二范式（2NF）。要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。任何非主键直接依赖其主键，不存在传递关系。

## 数据库的五大约束：

1主键约束 2唯一约束 3默认约束 4检查约束 5外键约束

**脏读，幻读，不可重复读的区别：**

**脏读**：表示一个事务能够读取另一个事务中还未提交的数据。

**幻读**：表示同一个事物内多次查询返回的结果集不一样。

**不可重复读**：表示在一个事务内，多次读同一数据。

## 数据库的优化：

首先知道数据量有多大

1数据预处理 2SQL语句优化 3添加索引和优化 4数据库引擎innoDB，myisam 5读写分离 6分表分区 7分布式数据库 8加缓存

INNODB 支持事务ACID，支持外键，行锁，查表总行数时，全表扫描。（适合读少写多）

MYISAM 不支持事务，不支持外键，表锁，插入数据时，锁定整个表，保存表的总行数。索引和数据分离。效率优于innoDB。（适合读多写少）

## [乐观锁和悲观锁的区别：](https://blog.csdn.net/qq_34337272/article/details/81072874)

**乐观锁使用版本号机制或CAS算法实现。**

**乐观锁：**每次去拿数据的时候都认为别人不会去修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。

**悲观锁：**每次去拿数据的时候都认为别人会修改数据，所以每次取数据时都会上锁，直到这个锁被释放。

**数据库加锁**：行级锁，表级锁，乐观锁，悲观锁。共享锁，排它锁。

## 聚簇索引和非聚簇索引的差异性:

\- 在聚簇索引中，索引树的叶级页包含实际的数据：记录的索引顺序与物理顺序相同。聚簇索引非常象目录表，目录表的顺序与实际的页码顺序是一致的。

\- 在非聚簇索引中，叶级页指向表中的记录：记录的物理顺序与逻辑顺序没有必然的联系。非聚簇索引则更象书的标准索引表，索引表中的顺序通常与实际的页码顺序是不一致的。一本书也许有多个索引。例如，它也许同时有主题索引和作者索引。同样，一个表可以有多个非聚簇索引。 

# MySQL：

## 行锁和表锁的区别

表级锁：开销小，加锁快，不会出现死锁。锁粒度大，并发量低。（MyIASM）

行级锁：开销大，加锁慢，会出现死锁。锁粒度小，并发度高。(InnoDB)

## 内连接、左连接、右连接的区别：

inner join;	left join;	 right join;

**内连接**（使用像 = 或 <> 之类的比较运算符）是把匹配的关联数据显示出来，两表的交集；

使用比较运算符根据每个表共有的列的值匹配两个表中的行

**外连接**分为左外连接，右外连接，完整外连接

左连接是以左表为参照，显示所有数据；

右连接是以右表为参照，显示所有数据；

联接列所匹配的行，如果左表的某行在右表中没有匹配行，则将为右表返回空值。

**交叉联接**返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。



# Redis

key-value非关系数据库，内存性数据库，数据保存内存中，速度快

## 基本数据类型

string list set hash sorted-set

## 支持事务

## Redis持久化

RDB(Redis DataBase) 和AOF(Append Only File)

**RDB** 默认持久化方案，在指定时间间隔内，指定次数写操作。将内存数据作快照文件写入磁盘中，即在指定目录下生成一个dump.rdb文件，Redis重启会通过加载rdb文件恢复数据。

优点：

1 适合大规模的数据恢复。

2 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。

缺点：

1 数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。

2 备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。

所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。

**AOF** 默认不开启，弥补RDB。采用日志的形式来记录每个写操作，并追加到文件中。Redis重启会根据日志文件内容将写指令从前到后执行一次以完成数据的恢复工作。

优点：数据的完整性和一致性更高

缺点：因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。

**总结**

1. Redis 默认开启RDB持久化方式，在指定的时间间隔内，执行指定次数的写操作，则将内存中的数据写入到磁盘中。
2. RDB 持久化适合大规模的数据恢复但它的数据一致性和完整性较差。
3. Redis 需要手动开启AOF持久化方式，默认是每秒将写操作日志追加到AOF文件中。
4. AOF 的数据完整性比RDB高，但记录内容多了，会影响数据恢复的效率。
5. Redis 针对 AOF文件大的问题，提供重写的瘦身机制。
6. 若只打算用Redis 做缓存，可以关闭持久化。
7. 若打算使用Redis 的持久化。建议RDB和AOF都开启。其实RDB更适合做数据的备份，留一后手。AOF出问题了，还有RDB

# MongoDB

**文档性数据库 存放xml,json,bson**

不支持事务

**关系型数据库**Oracle Mysql SQLServer DB2 PostgreSQL SQLite Teradata Access MariaDB SAP

**非关系型数据库**Redis MongoDB Cassandra Hbase MemcacheDB