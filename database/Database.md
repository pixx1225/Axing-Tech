[TOC]

# 数据库知识总汇

## JDBC

### JDBC数据库连接的基本步骤：

1.加载JDBC驱动到JVM，将Driver类的实例注册到DriverManager类中

2.提供JDBC连接的URL，定义了连接数据库时的协议、子协议、数据源标识

3.创建数据库的连接，向java.sql.DriverManager请求并获得Connection对象

4.创建一个Statement

5.执行SQL语句，Statement接口提供了三种执行SQL语句的方法：executeQuery 、executeUpdate	和execute

6.获取并操作结果集，

7.关闭JDBC对象  

操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声明顺序相反：  

1、关闭记录集  2、关闭声明  3、关闭连接对象

```java
public static void main(String[] args){
  Connection conn = null;
  PreparedStatement ps = null;
  ResultSet rs = null;
  try{
    //加载数据库驱动
    Class.forName("com.mysql.jdbc.Driver");
    //通过驱动管理类获取数据库链接
    conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8","root","passport");
    //定义sql语句，？表示占位符
    String  sql = "select * from user where username = ?";
    //获取预处理statement
    ps = conn.prepareStatement(sql);
    //设置参数
    ps.setString(1,"王五");
    //向数据库发出sql执行查询，查询出结果集
    rs = ps.executeQuery();
    //遍历查询结果集
    while(rs.next()){
      System.out.println(rs.getString("id")+" "+rs.getString("username"));
    }
  }catch (Exception e){
    e.printStackTrace();
  }finally{
    //释放资源
    if(rs != null){
      try{
        rs.close();
      }catch(SQLException e){
        e.printStackTrace();
      }
    }
    if(ps != null){
      try{
        ps.close();
      }catch(SQLException e){
        e.printStackTrace();
      }
    }
    if(conn != null){
      try{
        conn.close();
      }catch(SQLException e){
        e.printStackTrace();
      }
    }
  }
}
```

## 查询语句SQL是如何执行的

![SQL查询语句执行流程](https://github.com/pixx1225/Axing-Tech/blob/master/images/SQL查询流程.png)

大体来说，MySQL可以分为`Server`层和`存储引擎`层两部分

* `Server`层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
* `存储引擎层`负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分

**连接器**

第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在`show processlist`命令中看到它。客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数`wait_timeout`控制的，默认值是`8`小时。数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。

**查询缓存**

MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。

如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。（大多数情况下不要使用查询缓存，因为查询缓存的失效非常频繁。）

**分析器**

首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。分析器先会做`“词法分析”`,词法分析完后就要做`“语法分析”`。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒

**优化器**

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。

> 比如你执行下面这样的语句，这个语句是执行两个表的join：
> `mysql> select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;`
> 既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。
> 也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。
> 这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。

**执行器**

MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误。如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。

> `mysql> select * from T where ID=10;`
> 比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：
> 调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；
> 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
> 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

## 更新语句SQL是如何执行的

> update table set c=c+1 where ID=2;

更新流程还涉及两个重要的日志模块 `redo log`（重做日志）和 `binlog`（归档日志）

​	MySQL的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是`先写日志`，`再写磁盘`，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。但是InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB,总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写。在进行redo log写入时，有两个重要参数的write pos是当前记录的位置,checkpoint是当前要擦除的位置。

`redo log是InnoDB引擎特有的`；binlog是MySQL的Server层实现的，所有引擎都可以使用。`redo log是物理日志`，记录的是“在某个数据页上做了什么修改”；`binlog是逻辑日志`，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。`redo log是循环写的`，`空间固定`会用完；`binlog是可以追加写入的`。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

* Redo log不是记录数据页“更新之后的状态”，而是记录这个页 “做了什么改动”。
* Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。

## 数据库引擎

### InnoDB

支持事务ACID，支持外键，行锁，查表总行数时，全表扫描。（适合读少写多）

InnDB是Mysql默认的事务型存储引擎。它被设计用来处理大量的短期(short-lived) 事务，短期事务大部分情况是正常提交的，很少会被回滚。InnoDB的数据存储在表空间(tablespace) 中。

InnoDB采用`MVCC`来支持高并发，并且实现了四个标准的隔离级别。其默认级别是
REPEATABLE READ (`可重复读`) ,并且通过`间隙锁`(next-key locking)策略防止`幻读`的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。

InnoDB表是基于聚簇索引建立的。聚簇素引对主键查询有很高的性能，不过它的二级索引(secondary index，非主键索引)中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。

### MyISAM

不支持事务，不支持外键，表锁，插入数据时，锁定整个表，保存表的总行数。索引和数据分离。效率优于innoDB。（适合读多写少）

优点是对于只读的数据，或者表比较小，可以忍受修复操作，可以继续使用

## 数据库索引

### 索引模型：

* `哈希表`：一种以`key-value` 存储数据的结构，哈希的思路是把值放在数组里，用一个哈希函数把`key`换算成一个确定的位置，然后把`value`放在数组的这个位置。哈希冲突的处理办法是使用`链表`。哈希表适用只有`等值查询`的场景
* `有序数组`：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))。查询效率高，更新效率低（涉及到移位）。在等值查询和范围查询场景中的性能就都非常优秀。有序数组索引只适用于静态存储引擎。
* `搜索树`：每个节点的左儿子小于父节点，右儿子大于父节点。查询时间复杂度O(log(N))，更新时间复杂度O(log(N))。数据库存储大多不适用二叉树，因为树高过高，会适用N叉树

**索引类型**分为`主键索引`和`非主键索引`。主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为`聚簇索引`。非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为`二级索引`

![](https://github.com/pixx1225/Axing-Tech/blob/master/images/索引查询.png)

**主键索引和普通索引的查询有什么区别？**

* 如果语句是`select * from T where ID=500`，即主键查询方式，则只需要搜索ID这棵B+树；
* 如果语句是`select * from T where k=5`，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为`回表`。

基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询

索引是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。**索引的实现通常使用B树及其变种B+树**。

### B+树

**优点**解答:创建索引可以大大提高系统的性能。 (1) 大大加快数据的检索速度，这也是创建索引的最主要原因。 (2) 创建唯一性索引，保证数据库表中每一行数据的唯一性。 (3) 加速表和表之间的连接。 (4) 在使用分组(group by)和排序(order by)子句进行数据检索时，可以显著减少查询中分组和排序的时间。 (5) 通过使用索引，可以在查询的过程中，使用查询优化器，提高系统的性能。 那么索引有如此多的优点，为什么不对表中的

**每一个列创建一个索引**呢？这是因为增加索引也有许多不利的方面。 (1) 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 (2) 索引需要占用物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 (3) 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 

一般来说，应该在这些列上**创建索引**: (1) 在经常需要搜索的列上创建索引，可以加快搜索的速度; (2) 在作为主键的列上创建索引，强制该列的唯一性和组织表中数据的排列结构; (3) 在经常用在连接的列上创建索引，这些列主要是一些外键，可以加快连接的速度; (4) 在经常需要根据范围进行搜索的列上创建索引，囚为索引已经排序，其指定的范围是连续的; (5) 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间: (6) 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 同样，对于有些列不应该创建索引。

一般来说，**不应该创建索引**的这些列具有下列特点: (1) 对于那些在查询中很少使用的列不应该创建索引。这是因为，既然这些列很少使用到，因此有无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度，增大了空间需求。 (2) 对于那些只有很少数据值的列也不应该创建索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占据了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 (3) 对于那些定义为text和bit等数据类型的列不应该创建索引。这是因为，这些列的数据量要么相当大，要么取值很少，不利于使用索引。 (4) 当修改操作远远大于检索操作时，不应该创建索引。这是因为，修改性能和检索性能是互相相矛盾的。当增加索引时，会提高检索的性能，但是会降低修改的性能。当减少索引时，会提高修改的性能，降低检索的性能。因此，当修改操作远远多于检索操作时，不应该创建索引。

### 红黑树

等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：

（一）更少的查找次数。平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。

（二）利用磁盘预读特性。为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。

## 数据库事务

### 数据库事务四大特性：

ACID atomicity consistency isolation durability

原子性，一致性，隔离性，持久性

### 数据库事务隔离四个级别：

**读未提交Read uncommitted**：最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）

**读已提交Read committed**：一个事务提交后才能被其他事务读取到（会出现幻读、不可重复读）

**可重复读Repeatable read**：默认级别，保证多次读取同一数据内容一致，禁止读取事务未提交的数据（会出现幻读）

**串行化Serializable**：代价最高最可靠的隔离级别，防止脏读、幻读、不可重复读。

## 脏读、不可重复读、幻读

脏读（读取未提交数据）：脏读发生在一个事务A读取了被另一个事务B修改，但是还未提交的数据。假如B回退，则事务A读取的是无效的数据。

不可重复读（前后多次读取，数据内容不一致）：事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。

幻读（前后多次读取，数据总量不一致）：事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。（多次查询返回的结果集不一样）

## 数据库三范式：

第一范式：如果关系模式R的每个关系r的属性都是不可分的数据项。每一个属性都是原子项，不可分割。

第二范式：如果关系模式R是1NF，且每个非主键属性完全函数依赖于候选键

第三范式：满足第二范式（2NF）。要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。任何非主键直接依赖其主键，不存在传递关系。

## 数据库的五大约束：

1主键约束 2唯一约束 3默认约束 4检查约束 5外键约束

## 数据库的优化：

首先知道数据量有多大

1数据预处理 2SQL语句优化 3添加索引和优化 4数据库引擎innoDB，myisam 5读写分离 6分表分区 7分布式数据库 8加缓存

## [乐观锁和悲观锁的区别：](https://blog.csdn.net/qq_34337272/article/details/81072874)

**乐观锁使用版本号机制或CAS算法实现。**

**乐观锁：**每次去拿数据的时候都认为别人不会去修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。

**悲观锁：**每次去拿数据的时候都认为别人会修改数据，所以每次取数据时都会上锁，直到这个锁被释放。

**数据库加锁**：行级锁，表级锁，乐观锁，悲观锁。共享锁，排它锁。

## 聚簇索引和非聚簇索引的区别:

\- 在聚簇索引中，索引树的叶级页包含实际的数据：记录的索引顺序与物理顺序相同。聚簇索引非常象目录表，目录表的顺序与实际的页码顺序是一致的。

\- 在非聚簇索引中，叶级页指向表中的记录：记录的物理顺序与逻辑顺序没有必然的联系。非聚簇索引则更象书的标准索引表，索引表中的顺序通常与实际的页码顺序是不一致的。一本书也许有多个索引。例如，它也许同时有主题索引和作者索引。同样，一个表可以有多个非聚簇索引。 

# MySQL：

## 行锁和表锁的区别

表级锁：开销小，加锁快，不会出现死锁。锁粒度大，并发量低。（MyIASM）

行级锁：开销大，加锁慢，会出现死锁。锁粒度小，并发度高。(InnoDB)

## 内连接、左连接、右连接的区别：

inner join;	left join;	 right join;

**内连接**（使用像 = 或 <> 之类的比较运算符）是把匹配的关联数据显示出来，两表的交集；

使用比较运算符根据每个表共有的列的值匹配两个表中的行

**外连接**分为左外连接，右外连接，完整外连接

左连接是以左表为参照，显示所有数据；

右连接是以右表为参照，显示所有数据；

联接列所匹配的行，如果左表的某行在右表中没有匹配行，则将为右表返回空值。

**交叉联接**返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。

## datetime和timesamp

* datetime和timesamp都可以存储相同的数据类型,时间和日期，精确到秒。然而timesamp只使用datetime一半的存储空间
* timesamp 会根据时区变化，具有特殊的自动更新能力，允许的时间范围要小很多，有时它的特许能力会成为障碍

# Redis

key-value非关系数据库，内存性数据库，数据保存内存中，速度快

## 基本数据类型

string list set hash sorted-set

## 支持事务

## Redis持久化

RDB(Redis DataBase) 和AOF(Append Only File)

**RDB** 默认持久化方案，在指定时间间隔内，指定次数写操作。将内存数据作快照文件写入磁盘中，即在指定目录下生成一个dump.rdb文件，Redis重启会通过加载rdb文件恢复数据。

优点：

1 适合大规模的数据恢复。

2 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。

缺点：

1 数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。

2 备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。

所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。

**AOF** 默认不开启，弥补RDB。采用日志的形式来记录每个写操作，并追加到文件中。Redis重启会根据日志文件内容将写指令从前到后执行一次以完成数据的恢复工作。

优点：数据的完整性和一致性更高

缺点：因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。

**总结**

1. Redis 默认开启RDB持久化方式，在指定的时间间隔内，执行指定次数的写操作，则将内存中的数据写入到磁盘中。
2. RDB 持久化适合大规模的数据恢复但它的数据一致性和完整性较差。
3. Redis 需要手动开启AOF持久化方式，默认是每秒将写操作日志追加到AOF文件中。
4. AOF 的数据完整性比RDB高，但记录内容多了，会影响数据恢复的效率。
5. Redis 针对 AOF文件大的问题，提供重写的瘦身机制。
6. 若只打算用Redis 做缓存，可以关闭持久化。
7. 若打算使用Redis 的持久化。建议RDB和AOF都开启。其实RDB更适合做数据的备份，留一后手。AOF出问题了，还有RDB

# MongoDB

**文档性数据库 存放xml,json,bson**

不支持事务

**关系型数据库**Oracle Mysql SQLServer DB2 PostgreSQL SQLite Teradata Access MariaDB SAP

**非关系型数据库**Redis MongoDB Cassandra Hbase MemcacheDB