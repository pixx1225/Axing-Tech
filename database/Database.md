[TOC]

# JDBC

## JDBC数据库连接的基本步骤：

1.加载JDBC驱动到JVM，将Driver类的实例注册到DriverManager类中

2.提供JDBC连接的URL，定义了连接数据库时的协议、子协议、数据源标识

3.创建数据库的连接，向java.sql.DriverManager请求并获得Connection对象

4.创建一个Statement

5.执行SQL语句，Statement接口提供了三种执行SQL语句的方法：executeQuery 、executeUpdate	和execute

6.获取并操作结果集，

7.关闭JDBC对象  

操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声明顺序相反：  

1、关闭记录集  2、关闭声明  3、关闭连接对象

```java
public static void main(String[] args){
  Connection conn = null;
  PreparedStatement ps = null;
  ResultSet rs = null;
  try{
    //加载数据库驱动
    Class.forName("com.mysql.jdbc.Driver");
    //通过驱动管理类获取数据库链接
    conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8","root","passport");
    //定义sql语句，？表示占位符
    String  sql = "select * from user where username = ?";
    //获取预处理statement
    ps = conn.prepareStatement(sql);
    //设置参数
    ps.setString(1,"王五");
    //向数据库发出sql执行查询，查询出结果集
    rs = ps.executeQuery();
    //遍历查询结果集
    while(rs.next()){
      System.out.println(rs.getString("id")+" "+rs.getString("username"));
    }
  }catch (Exception e){
    e.printStackTrace();
  }finally{
    //释放资源
    if(rs != null){
      try{
        rs.close();
      }catch(SQLException e){
        e.printStackTrace();
      }
    }
    if(ps != null){
      try{
        ps.close();
      }catch(SQLException e){
        e.printStackTrace();
      }
    }
    if(conn != null){
      try{
        conn.close();
      }catch(SQLException e){
        e.printStackTrace();
      }
    }
  }
}
```



# 数据库索引

是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。**索引的实现通常使用B树及其变种B+树**。

## B+树

**优点**解答:创建索引可以大大提高系统的性能。 (1) 大大加快数据的检索速度，这也是创建索引的最主要原因。 (2) 创建唯一性索引，保证数据库表中每一行数据的唯一性。 (3) 加速表和表之间的连接。 (4) 在使用分组(group by)和排序(order by)子句进行数据检索时，可以显著减少查询中分组和排序的时间。 (5) 通过使用索引，可以在查询的过程中，使用查询优化器，提高系统的性能。 那么索引有如此多的优点，为什么不对表中的**每一个列创建一个索引**呢？这是因为增加索引也有许多不利的方面。 (1) 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 (2) 索引需要占用物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 (3) 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 一般来说，应该在这些列上**创建索引**: (1) 在经常需要搜索的列上创建索引，可以加快搜索的速度; (2) 在作为主键的列上创建索引，强制该列的唯一性和组织表中数据的排列结构; (3) 在经常用在连接的列上创建索引，这些列主要是一些外键，可以加快连接的速度; (4) 在经常需要根据范围进行搜索的列上创建索引，囚为索引已经排序，其指定的范围是连续的; (5) 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间: (6) 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 同样，对于有些列不应该创建索引。一般来说，**不应该创建索引**的这些列具有下列特点: (1) 对于那些在查询中很少使用的列不应该创建索引。这是因为，既然这些列很少使用到，因此有无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度，增大了空间需求。 (2) 对于那些只有很少数据值的列也不应该创建索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占据了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 (3) 对于那些定义为text和bit等数据类型的列不应该创建索引。这是因为，这些列的数据量要么相当大，要么取值很少，不利于使用索引。 (4) 当修改操作远远大于检索操作时，不应该创建索引。这是因为，修改性能和检索性能是互相相矛盾的。当增加索引时，会提高检索的性能，但是会降低修改的性能。当减少索引时，会提高修改的性能，降低检索的性能。因此，当修改操作远远多于检索操作时，不应该创建索引。

## 红黑树

等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：

（一）更少的查找次数。平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。

（二）利用磁盘预读特性。为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。

# 数据库事务

## 数据库事务四大特性：

ACID atomicity consistency isolation durability

原子性，一致性，隔离性，持久性

## 数据库事务隔离四个级别：

**Read uncommitted读未提交**：最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）

**Read committed读已提交**：一个事务提交后才能被其他事务读取到（会出现幻读、不可重复读）

**Repeatable read可重复读**：默认级别，保证多次读取同一数据内容一致，禁止读取事务未提交的数据（会出现幻读）

**Serializable串行化**：代价最高最可靠的隔离级别，防止脏读、幻读、不可重复读。

# 数据库三范式：

第一范式：如果关系模式R的每个关系r的属性都是不可分的数据项。每一个属性都是原子项，不可分割。

第二范式：如果关系模式R是1NF，且每个非主键属性完全函数依赖于候选键

第三范式：满足第二范式（2NF）。要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。任何非主键直接依赖其主键，不存在传递关系。

# 数据库的五大约束：

1主键约束 2唯一约束 3默认约束 4检查约束 5外键约束

**脏读，幻读，不可重复读的区别：**

**脏读**：表示一个事务能够读取另一个事务中还未提交的数据。

**幻读**：表示同一个事物内多次查询返回的结果集不一样。

**不可重复读**：表示在一个事务内，多次读同一数据。

# 数据库的优化：

首先知道数据量有多大

1数据预处理 2SQL语句优化 3添加索引和优化 4数据库引擎innoDB，myisam 5读写分离 6分表分区 7分布式数据库 8加缓存

INNODB 支持事务ACID，支持外键，行锁，查表总行数时，全表扫描。（适合读少写多）

MYISAM 不支持事务，不支持外键，表锁，插入数据时，锁定整个表，保存表的总行数。索引和数据分离。效率优于innoDB。（适合读多写少）

# [**乐观锁和悲观锁的区别：**](https://blog.csdn.net/qq_34337272/article/details/81072874)

**乐观锁使用版本号机制或CAS算法实现。**

**乐观锁：**每次去拿数据的时候都认为别人不会去修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。

**悲观锁：**每次去拿数据的时候都认为别人会修改数据，所以每次取数据时都会上锁，直到这个锁被释放。

**数据库加锁**：行级锁，表级锁，乐观锁，悲观锁。共享锁，排它锁。

# **聚簇索引和非聚簇索引的差异性:**

\- 在聚簇索引中，索引树的叶级页包含实际的数据：记录的索引顺序与物理顺序相同。聚簇索引非常象目录表，目录表的顺序与实际的页码顺序是一致的。

\- 在非聚簇索引中，叶级页指向表中的记录：记录的物理顺序与逻辑顺序没有必然的联系。非聚簇索引则更象书的标准索引表，索引表中的顺序通常与实际的页码顺序是不一致的。一本书也许有多个索引。例如，它也许同时有主题索引和作者索引。同样，一个表可以有多个非聚簇索引。 

# MySQL：

## 行锁和表锁的区别

表级锁：开销小，加锁快，不会出现死锁。锁粒度大，并发量低。（MyIASM）

行级锁：开销大，加锁慢，会出现死锁。锁粒度小，并发度高。(InnoDB)

## 内连接、左连接、右连接的区别：

inner join;	left join;	 right join;

**内连接**（使用像 = 或 <> 之类的比较运算符）是把匹配的关联数据显示出来，两表的交集；

使用比较运算符根据每个表共有的列的值匹配两个表中的行

**外连接**分为左外连接，右外连接，完整外连接

左连接是以左表为参照，显示所有数据；

右连接是以右表为参照，显示所有数据；

联接列所匹配的行，如果左表的某行在右表中没有匹配行，则将为右表返回空值。

**交叉联接**返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。



# Redis

key-value非关系数据库，内存性数据库，数据保存内存中，速度快

## 基本数据类型

string list set hash sorted-set

## 支持事务

## Redis持久化

RDB(Redis DataBase) 和AOF(Append Only File)

**RDB** 默认持久化方案，在指定时间间隔内，指定次数写操作。将内存数据作快照文件写入磁盘中，即在指定目录下生成一个dump.rdb文件，Redis重启会通过加载rdb文件恢复数据。

优点：

1 适合大规模的数据恢复。

2 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。

缺点：

1 数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。

2 备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。

所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。

**AOF** 默认不开启，弥补RDB。采用日志的形式来记录每个写操作，并追加到文件中。Redis重启会根据日志文件内容将写指令从前到后执行一次以完成数据的恢复工作。

优点：数据的完整性和一致性更高

缺点：因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。

**总结**

1. Redis 默认开启RDB持久化方式，在指定的时间间隔内，执行指定次数的写操作，则将内存中的数据写入到磁盘中。
2. RDB 持久化适合大规模的数据恢复但它的数据一致性和完整性较差。
3. Redis 需要手动开启AOF持久化方式，默认是每秒将写操作日志追加到AOF文件中。
4. AOF 的数据完整性比RDB高，但记录内容多了，会影响数据恢复的效率。
5. Redis 针对 AOF文件大的问题，提供重写的瘦身机制。
6. 若只打算用Redis 做缓存，可以关闭持久化。
7. 若打算使用Redis 的持久化。建议RDB和AOF都开启。其实RDB更适合做数据的备份，留一后手。AOF出问题了，还有RDB

# MongoDB

**文档性数据库 存放xml,json,bson**

不支持事务

**关系型数据库**Oracle Mysql SQLServer DB2 PostgreSQL SQLite Teradata Access MariaDB SAP

**非关系型数据库**Redis MongoDB Cassandra Hbase MemcacheDB