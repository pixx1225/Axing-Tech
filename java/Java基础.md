[TOC]

# Java基础

- javac HelloWorld.java
- java HelloWorld
---

## 封装，继承，多态

**封装**隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。

**继承**是为了重用父类代码。同时继承也为实现多态做了铺垫。

**多态**就是指一个引用变量在不同的情况下的多种状态。多态是指通过指向父类的指针，来调用在不同子类中实现的方法。三要素：继承，重写，父类引用指向子类对象

- 如果b类继承自a类，在main方法中new出b的对象(不带参数)，那么他执行的顺序是：父类a的静态方法-->子类b的静态方法-->父类a的非静态方法-->父类a的无参构造-->子类b的非静态方法-->子类b的无参构造方法
- 在父类无参构造里面调用了父类的XX方法 且子类重写了父类的XX方法，那么不会调用父类的XX，优先调用子类的XX方法，但是仍然可以在子类的XX方法里面使用super调用父类的XX方法。

## 接口和抽象类的区别

**从设计层面来说，抽象是对类的抽象，是一种模板设计，可以实现代码重用，接口是行为的抽象，是一种行为的规范。**

**接口** （Interface修饰）所有的方法在接口中不能有实现（所有方法都是抽象的）。接口无法被实例化。一个类只能继承一个类，但是可以实现多个接口。一个类实现接口的话要实现接口中的所有方法。成员变量默认是public static final有初始值，成员方法默认是public abstract，

**抽象类**（abstract修饰）可包含抽象和非抽象的方法，含有抽象方法的类必是抽象类。抽象类不能实例化，抽象类中的抽象方法只有方法体，没有具体实现。如果子类没有实现抽象父类的所有抽象方法，那么子类也必须定义为抽象类。抽象方法可以是public，protected或者是private，变量是friendly的可以在子类中重新定义。

如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类

如果你想实现多重继承，那么你必须使用接口

如果基本功能在不断改变，那么就需要使用抽象类

## 重写和重载的区别

**Override**(重写）父类与子类之间多态性的一种表现。对接口方法的实现中经常出现。方法名，参数，返回值，异常都一致，方法被定义为final不能被重写。

**Overload**(重载)  是一个类中多态性的一种表现。方法名必须相同，参数列表不同（类型，个数，顺序）

## final，finally，finalize的区别

**final** 被final修饰的类，就意味着不能再派生出新的子类，变量或方法声明为final，可以保证他们在使用的过程中不被修改，只能读取使用。被声明为final的变量必须在声明时给出变量的初始值，final声明的方法不能重写。

**finally** 是在异常处理时提供finally块来执行任何清除操作。不管有没有异常被抛出、捕获，finally块都会被执行。

**finalize** 是方法名，在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。

## String、StringBuffer、StringBuilder的区别

在执行速度上：Stringbuilder->Stringbuffer->String

**String**：不可变，即字符串常量。操作少量的数据

**StringBuffer**：可变，效率低，线程安全，会在append等方法上加synchronized关键字，进行同步。多线程操作字符串缓冲区下操作大量数据

**StringBuilder**：可变，效率高，线程不安全。单线程操作字符串缓冲区下操作大量数据

+号拼接的原理是会在底层new一个StringBuilder，例如：str = str + “a”具体就是new StringBuilder().append(str).append("a"); 影响效率。

## ==和equals的区别

1）对于 **= =**，如果作用于基本数据类型的变量，则直接比较其存储的**值**是否相等；如果作用于引用类型的变量，则比较的是所指向的**对象的地址**。

2）对于**equals**方法，注意：equals方法不能作用于基本数据类型的变量；

如果没有对equals重写，则比较的是引用类型的变量所指向的**对象的地址**；

诸如String、Date等类进行了重写的话，比较的是所指向的对**象的内容**。

对于**字符串**，==比较两个对象的内存地址，equals比较字符串内容。

## sleep()和wait()的区别

①**sleep**是Thread类的方法，导致此线程暂停执行指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。

②**wait**是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。

## Java集合

### HashMap  

底层是用hash数组和单链表

键值对（key-value)    ：不同步，不是线程安全，允许键值都为null，映射无序，快速失败   初始容量（capacity）：默认16    加载因子（loadfactor)：默认0.75

扩容极限（threshold) ：元素个数大于capacity*loadfactor， 扩容2n，

进行rehash是非常耗资源的   jdk1.8 链表长度大于8时转换为**红黑树**

### ConcurrentHashMap 

线程安全，支持16个线程并发操作，

- 分段锁（Segment）的设计，把一个大的Map拆分成N个小的HashTable
- Segment继承ReentrantLock,每个Segment都有一把锁，保证线程安全。

非阻塞，效率高。

### HashTable

线程安全，key和value不允许null。HashTable中hash数组默认大小是11扩容2n+1。任何操作都会把整个表锁住，阻塞，效率低。

### TreeMap 

继承自SortedMap接口，非线程安全，基于红黑树实现，适用于顺序遍历键

### ArrayList

底层的数据结构是基于动态数组。适合查找。默认容量为10。扩容按照1.5倍+1增长

### LinkedList

底层的数据结构是基于双向循环链表。适合增删。比ArrayList更占内存，

## 装箱和拆箱的区别

Java为每种基本数据类型都提供了对应的包装器类型，

装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。

## 对象序列化和反序列化

> - 对象序列化：将对象以二进制的形式保存在硬盘上；
> - 反序列化：将二进制的文件转化为对象读取；
> - 实现 serializable 接口可以实现对象序列化，其中没有需要实现的方法，implements Serializable 只是为了标注该对象是可被序列化的。