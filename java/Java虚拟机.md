[TOC]

# JVM

## 运行时数据区域

- Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途,以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。

![运行时数据区](../images/运行时数据区.jfif)

- 线程私有的：虚拟机栈，本地方法栈，程序计数器
- 线程共享的 方法区，堆

### 1 程序计数器
- 程序计数器是一块较小的内存空间,它的作用可以看作是当前线程所执行的字节码行号指示器，在虚拟机的概念模型里，字节码解释器工作时 就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支,循环,跳转,异常处理,线程恢复等基础功能都需要这个计数器来完成。（如果正在执行的是本地方法则计数器为空）。

### 2 Java虚拟机栈
- 虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。

### 3 本地方法栈
- 本地方法栈与Java虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。

### 4 Java 堆
- `Java` 堆是整个虚拟机所管理的最大内存区域，所有的对象创建都是在这个区域进行内存分配。
- 这块区域也是垃圾回收器重点管理的区域，由于大多数垃圾回收器都采用`分代回收算法`，所有堆内存也分为 `新生代`、`老年代`，可以方便垃圾的准确回收。

### 5 方法区
- 方法区主要用于存放已经被虚拟机加载的类信息，如`常量，静态变量`，即时编译器编译后的代码等。和Java堆一样不需要连续的内存，并且可以动态扩展。
- 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。

## 虚拟机类加载机制

### 类加载的时机
- 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期如下：

![类加载生命周期](../images/类加载生命周期.jfif)

- 其中准备、验证、解析3个部分统称为连接（Linking）。加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定

### 类的加载过程

**1. 加载**

```
1.通过一个类的全限定名来获取定义此类的二进制字节流
2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
```

**2. 验证**

- 确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段不是必须的。

```
1.文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
2.元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。
3.字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的
4.符号引用验证：确保解析动作能正确执行。
```

**3. 准备**

- 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。

**4. 解析**

- 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

**5. 初始化**

- 如果一个类被主动引用，就会触发类的初始化。
- 在java中，直接引用的情况有，通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法。通过反射方式执行以上三种行为。初始化子类的时候，会触发父类的初始化。作为程序入口直接运行时（也就是直接调用main方法）。除了以上四种情况，其他使用类的方式叫做被动引用，而被动引用不会触发类的初始化

**6. 使用**

- 类的使用包括主动引用和被动引用
- 被动引用：引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。定义类数组，不会引起类的初始化。引用类的常量，不会引起类的初始化。

**7. 卸载**

- 满足下面的情况，类就会被卸载：该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。加载该类的ClassLoader已经被回收。该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。
- 如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。

**总结**

- 对象基本上都是在jvm的堆区中创建，在创建对象之前，会触发类加载（加载、连接、初始化），当类初始化完成后，根据类信息在堆区中实例化类对象，初始化非静态变量、非静态代码以及默认构造方法，当对象使用完之后会在合适的时候被jvm垃圾收集器回收。

## 内存模型（JMM, Java Memory Model)

JVM内存结构分为：Java堆，方法区，程序计数器，本地方法栈，虚拟机栈

## 如何确定垃圾回收

引用计数：count标记对象引用的次数，会有循环引用的问题

可达性分析：从gc roots对象计算可以到达的对象

## 垃圾回收算法

**标记-清除算法Mark-Sweep：**首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。标记清除最大的问题就是内存的碎片化严重(可用内存不连续)，后续可能发生大对象不能找到可利用空间的问题。

**复制算法Copying：**将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块内存用完了，将复制到另外一块上面，然后在把已使用过的内存空间一次清理掉。效率高，解决了内存碎片化的问题，同时可以压缩内存，但是浪费内存(所有内存分为两部分，只能使用其中一半的内存)。

**标记-整理算法Mark-Compact：**标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让索引端移动，然后直接清理掉端边界以外的内存。效率比Cpoy略低，一般用于老年代。

**分代收集算法**：对于不同的代，采用不同的收集算法：

新生代：由于对象存活时间短，数量少，因此可以采用复制算法该算法效率比较快。

老年代：由于对象存活时间长，数量多，可以采用标记-清除算法或是标记-整理算法。

**常见的垃圾收集器**

新生代：Serial，ParNew，Parallel Scavenge

老年代：Serial Old，CMS，Parallel Old

最新：G1收集器

## JVM性能调优

JVM参数

```
- ： 标准参数，所有JVM都应该支持
-X： 非标准参数，每个JVM实现都不同
-XX：不稳定参数，下一个版本可能会取消
```

```undefined
堆设置
-Xms：初始堆大小
-Xmx：最大堆大小
-Xss：线程堆大小
-XX:NewSize=n：设置年轻代大小       
-XX:SurvivorRatio=n：年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5
-XX:MaxPermSize=n：设置持久代大小

收集器设置
-XX:+UseSerialGC：设置串行收集器
-XX:+UseParallelGC：设置并行收集器
-XX:+UseConcMarkSweepGC：设置并发收集器

垃圾回收统计信息    
-XX:+PrintGC
-XX:+PrintGCDetails
-Xloggc:filename
```

```java
tomcat 的bin目录下，catalina.bat中进行设置
set JAVA_OPTS=
   -Xms4g
   -Xmx4g
   -Xss512k
   -XX:+AggressiveOpts  //虚拟机中能用到的优化项都设置上，包括升级后的优化项
   -XX:+UseBiasedLocking   //优化锁的
   -XX:PermSize=64M （Java1.8没有了） //永久区的大小
   -XX:MaxPermSize=300M         //永久区最大大小
   -XX:+DisableExplicitGC          //关掉显示调用GC  【System.gc();】
   -XX:+UseConcMarkSweepGC   //使用CMS缩短响应时间，并发收集，低停顿
   -XX:+UseParNewGC   //并发收集新生代的垃圾
   -XX:+CMSParallelRemarkEnabled  //在使用UseParNewGC的情况看下，尽量减少mark的时间
   -XX:+UseCMSCompactAtFullCollection //使用并发收集器时，开启对年老代的压缩，使碎片减少
   -XX:LargePageSizeInBytes=128m  //内存分页大小对性能的提升
   -XX:+UseFastAccessorMethods    //get/set方法转成本地代码
   -Djava.awt.headless=true  //修复linux下的tomcat处理图表时可能产生的一个bug
```

## JVM调优命令

```java
jps       #查看当前java进程
jstat     #查看堆内存各部分的使用情况，以及加载类的数量
jinfo     #查看Java进程运行的JVM参数，系统属性等
jmap      #生成运行中的jvm的堆的快照
jstack    #生成jvm当前时刻的线程快照
```

## JVM调优工具

### jconsole

JMX的可视化管理工具

### VisualVM

多合一故障管理工具

## 内存泄露

对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着。

Java 内存泄漏的几种情况：

- 静态集合类：如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。
- 资源未关闭：各种连接，如数据库连接、网络连接和IO连接等，文件读写等，造成的内存泄漏
- 此外还有诸如 监听器、内存类、单例模式等等场景的使用，都有可能造成内存泄漏

避免内存泄漏的方法

- 好的编码习惯：对可能出现内存泄漏的场景给予“特殊关照”：    
  - 注意像 HashMap 、ArrayList 的集合对象
  - 注意 事件监听 和 回调函数
  - 在确认一个对象无用后，将其所有引用显式的置为null；
  - 数据库连接，使用 `try…finally` 结构，在 finally 中关闭 Statement 对象和连接。
- 好的测试工具：在开发中不能完全避免内存泄漏，关键要在发现有内存泄漏的时候能用好的测试工具迅速定位问题的所在。

